<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/libs/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/libs/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="“web前端, 程序猿, 文艺小青年”" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="To the world you may be one person,but to one person you may be the world.">
<meta property="og:type" content="website">
<meta property="og:title" content="最晚的开始">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="最晚的开始">
<meta property="og:description" content="To the world you may be one person,but to one person you may be the world.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="最晚的开始">
<meta name="twitter:description" content="To the world you may be one person,but to one person you may be the world.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>


  <title> 最晚的开始 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">最晚的开始</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">所有的为时已晚都是开始的最好时候</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/原型链md/" itemprop="url">
                  原型链&原型继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:48+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##原型链<br>在<code>JavaScript</code>中，每个对象都有一个<code>[[Prototype]]</code>属性，其保存着的地址就构成了对象的原型链。</p>
<p><code>[[Prototype]]</code>属性是js编译器在对象被创建时自动添加的，其取值由new运算符的右侧参数决定。字面量的方式可转化为new Obejct();</p>
<pre><code>var x = new Xzavier();
vae o = {};  //var o = new Obejct();
</code></pre><p>通过对象的<code>[[Prototype]]</code>保存对另一个对象的引用，通过这个引用往上进行属性的查找，这就是原型链查找机制。</p>
<p>对象在查找某个属性的时候，会首先遍历自身的属性，如果没有则会继续查找<code>[[Prototype]]</code>引用的对象，如果再没有则继续查找<code>[[Prototype]].[[Prototype]]</code>引用的对象，依次类推，直到<code>[[Prototype]].….[[Prototype]]</code>为<code>undefined</code></p>
<p>（<code>Object.prototype的[[Prototype]]</code>就是undefined）</p>
<pre><code>function Xzavier() {
    this.name = &apos;xzavier&apos;;
}
var x = new Xzavier();
x.age = 23;

console.log(x.job);  // 获取x的job属性 undefined
</code></pre><p>1、遍历x对象本身，结果x对象本身没有job属性</p>
<p>2、找到x的[[Prototype]]，也就是其对应的对象Xzavier.prototype，同时进行遍历。 Xzavier.prototype也没有job属性</p>
<p>3、找到Xzavier.prototype对象的[[Prototype]]，指向其对应的对象Object.prototype。Object.prototype也没有job属性</p>
<p>4、寻找Object.prototype的[[Prototype]]属性，返回undefined。</p>
<p>##函数的变量和内部函数</p>
<p>###私有变量和内部函数</p>
<p>私有成员，即定义函数内部的变量或函数，外部无法访问。</p>
<pre><code>function Xzavier(){
    var name = &quot;xzavier&quot;; //私有变量
    var sports = function() {console.log(&apos;basketball&apos;)}; //私有函数 
}
var x = new Xzavier();
x.name;  //undefined
</code></pre><p>如果要访问，需要对外提供接口。</p>
<pre><code>function Xzavier(){
    var name = &quot;xzavier&quot;; //私有变量
    var sports = function() {console.log(&apos;basketball&apos;)}; //私有函数
    return{
        name: name,
        sports: sports
    }
}
var x = new Xzavier();
x.name;  //&quot;xzavier&quot;
</code></pre><p>###静态变量和内部函数</p>
<p>用点操作符定义的静态变量和内部函数就是实例不能访问到的变量和内部函数。只能通过自身去访问。</p>
<pre><code>function Xzavier(){
    Xzavier.name = &quot;xzavier&quot;; //静态变量
    Xzavier.sports = function() {console.log(&apos;basketball&apos;)}; //静态函数 
}
Xzavier.name; //&quot;xzavier&quot;
var x = new Xzavier();
x.name;  //undefined
</code></pre><p>###实例变量和内部函数</p>
<p>通过this定义给实例使用的属性和方法。</p>
<pre><code>function Xzavier(){
    this.name = &quot;xzavier&quot;; //实例变量
    this.sports = function() {console.log(&apos;basketball&apos;);}; //实例函数 
}
Xzavier.name; //undefined
var x = new Xzavier();
x.name;  //&quot;xzavier&quot;
</code></pre><p>##原型链继承<br>有了原型链，就可以借助原型链实现继承。</p>
<pre><code>function Xzavier() {
    this.name = &apos;xzavier&apos;;
    this.sex = &apos;boy&apos;;
    this.job = &quot;jser&quot;;
}

function X() {};
</code></pre><p>X的原型<code>X.prototype</code>原型本身就是一个<code>Object</code>对象。F12打开控制台输入函数，再打印<code>X.prototype:</code></p>
<pre><code>Object {
    constructor: X()
    __proto__: Object
}
</code></pre><p><code>prototype</code>本身是一个<code>Object</code>对象的实例，所以其原型链指向的是Object的原型。</p>
<p><strong>X.prototype = Xzavier.prototype</strong></p>
<pre><code>X.prototype = Xzavier.prototype;
</code></pre><p>这样相当于把X的<code>prototype</code>指向了Xzavier的<code>prototyp</code>e；这样只是继承了Xzavier的<code>prototype</code>方法，Xzavier中的自定义方法则不继承。</p>
<pre><code>X.prototype.love = &quot;dog&quot;;
</code></pre><p>这样也会改变Xzavier的<code>prototype</code>，所以这样基础就不好。</p>
<p><strong>X.prototype = new Xzavier()</strong></p>
<pre><code>X.prototype = new Xzavier();
</code></pre><p>这样产生一个Xzavier的实例，同时赋值给X的原型，也即<code>X.prototype</code>相当于对象：</p>
<pre><code>{
    name: &quot;xzavier&quot;, 
    sex: &quot;boy&quot;, 
    job: &quot;jser&quot;,
    [[Prototype]] : Xzavier.prototype
}
</code></pre><p>这样就把Xzavier的原型通过<code>X.prototype.[[Prototype]]</code>这个对象属性保存起来，构成了原型的链接。不过，这样X产生的对象的构造函数发生了改变，因为在X中没有<code>constructor</code>属性，只能从原型链找到<code>Xzavier.prototype</code>，读出<code>constructor:Xzavier。</code></p>
<pre><code>var x = new X;
console.log(x.constructor);
</code></pre><p>输出：</p>
<pre><code>Xzavier() {
    this.name = &apos;xzavier&apos;;
    this.sex = &apos;boy&apos;;
    this.job = &quot;jser&quot;;
}
</code></pre><p>手动改正：</p>
<pre><code>X.prototype.constructor = X;
</code></pre><p>这是X的原型就多了个属性constructor，指向X</p>
<pre><code>function Xzavier() {
    this.name = &apos;xzavier&apos;;
    this.sex = &apos;boy&apos;;
    this.job = &quot;jser&quot;;
}

function X(){}
X.prototype = new Xzavier();
var x = new X()
x.name  // &quot;xzavier&quot;
</code></pre><p>###hasOwnProperty<br><code>hasOwnProperty</code>是<code>Object.prototype</code>的一个方法，判断一个对象是否包含自定义属性而不是原型链上的属性。<code>hasOwnProperty</code> 是JavaScript中唯一一个处理属性但是不查找原型链的函数。</p>
<pre><code>function Xzavier() {
    this.name = &apos;xzavier&apos;;
    this.sex = &apos;boy&apos;;
    this.job = &quot;jser&quot;;
}
//给A的原型对象添加属性
Xzavier.prototype.sports = function() {console.log(&apos;basketball&apos;);};

var x = new Xzavier();
x.name; // &apos;xzavier&apos;
&apos;sex&apos; in x; // true

x.hasOwnProperty(&apos;job&apos;); // true
x.hasOwnProperty(&apos;sports&apos;); // false
</code></pre><p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code> 是非常推荐的方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/前端开发面试题/" itemprop="url">
                  前端面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:48+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HR/" itemprop="url" rel="index">
                    <span itemprop="name">HR</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>HTML</h2><br><em> 浏览器的内核分别是什么?
  </em> IE浏览器的内核<code>Trident、Mozilla</code>的<code>Gecko、Chrom</code>e的<code>Blink</code>（<code>WebKi</code>t的分支）、<code>Opera</code>内核原为<code>Prest</code>o，现为<code>Blink</code>；<br><em> 常见兼容性问题？
  </em> png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.<br>  <em> 浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的`</em>{margin:0;padding:0;}<code>来统一。
  * IE6双边距</code>bug:<code>块属性标签</code>float<code>后，又有横行的</code>margin<code>情况下，在ie6显示</code>margin<code>比设置的大。
浮动ie产生的双倍距离</code>#box{ float:left; width:10px; margin:0 0 0 100px;}<code>这种情况之下IE会产生20px的距离，解决方案是在</code>float<code>的标签样式控制中加入 ——</code><em>display:inline`;将其转化为行内属性。(</em>这个符号只有ie6会识别)<br>渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br><br>            css<br>              .bb{<br>               background-color:#f1ee18;/<em>所有识别</em>/<br>              .background-color:#00deff\9; /<em>IE6、7、8识别</em>/<br>              +background-color:#a200ff;/<em>IE6、7识别</em>/<br>              _background-color:#1e0bd1;/<em>IE6识别</em>/<br>              }<br>  <em> IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用<code>getAttribute()</code>获取自定义属性;<br>Firefox下,只能使用<code>getAttribute()</code>获取自定义属性.<br>解决方法:统一通过<code>getAttribute()</code>获取自定义属性.
  </em> IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.<br><br>          <strong>解决方法：</strong>（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。<br>  <em> Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 <code>-webkit-text-size-adjust: none;</code> 解决.<br>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A :<br><br>            a:link {} a:visited {} a:hover {} a:active {}

</em> html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？<br>  <em> HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
  </em> 绘画 canvas<br><br>           用于媒介回放的 video 和 audio 元素<br><br>           本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br><br>           sessionStorage 的数据在浏览器关闭后自动删除<br><br>           语意化更好的内容元素，比如 article、footer、header、nav、section<br><br>           表单控件，calendar、date、time、email、url、search<br><br>           新的技术webworker, websockt, Geolocation<br><br>  <em> 移除的元素<br>   纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>   对可用性产生负面影响的元素：frame，frameset，noframes；<br>   支持HTML5新标签：
  </em> IE8/IE7/IE6支持通过document.createElement方法产生的标签，  可以利用这一特性让这些浏览器支持HTML5新标签，<br>   浏览器支持新标签后，还需要添加标签默认的样式：<br>  <em> 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<br>        <!--[if lt IE 9]>
        <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
        <![endif]--><br><br>        如何区分： DOCTYPE声明\新增的结构元素\功能元素

</em> 语义化的理解？<br><br>       用正确的标签做正确的事情！<br>       html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>       在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。<br>       搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。<br>       使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解<br><em> HTML5的离线储存？<br><br>       localStorage    长期存储数据，浏览器关闭后数据不丢失；<br>       sessionStorage  数据在浏览器关闭后自动删除。
</em> iframe有那些缺点？<br><br>       iframe会阻塞主页面的Onload事件；<br><br>       iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>       使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>       动态给iframe添加src属性值，这样可以可以绕开以上两个问题。<br><em> HTML5的form如何关闭自动完成功能？<br>   给不想要提示的 form 或下某个input 设置为 autocomplete=off。

</em> 请描述一下 cookies，sessionStorage 和 localStorage 的区别？<br><br>       cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会<br><br>       sessionStorage和localStorage的存储空间更大；<br><br>       sessionStorage和localStorage有更多丰富易用的接口；<br><br>       sessionStorage和localStorage各自独立的存储空间；<br>* 如何实现浏览器内多个标签页之间的通信?<br><br>       调用localstorge、cookies等本地存储方式<br><br><h2>CSS</h2>

<ul>
<li><p>介绍一下CSS的盒子模型？</p>
<p>  （1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;</p>
<p>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</p>
</li>
<li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
<ul>
<li><p>选择符 </p>
<ul>
<li>1.id选择器（ # myid）</li>
<li>2.类选择器（.myclassname）</li>
<li>3.标签选择器（div, h1, p）</li>
<li>4.相邻选择器（h1 + p）</li>
<li>5.子选择器（ul &gt; li）</li>
<li>6.后代选择器（li a）</li>
<li>7.通配符选择器（ * ）</li>
<li>8.属性选择器（a[rel = “external”]）</li>
<li>9.伪类选择器（a: hover, li: nth - child）</li>
</ul>
</li>
<li><p>可继承的样式： font-size font-family color, UL LI DL DD DT;</p>
</li>
<li>不可继承的样式：border padding margin width height ;</li>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;</li>
<li><p>优先级为:</p>
<pre><code>!important &gt;  id &gt; class &gt; tag
important 比 内联优先级高
</code></pre></li>
<li><p>CSS3新增伪类举例：</p>
<pre><code>p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
 :enabled  :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
</code></pre></li>
</ul>
</li>
<li><p>列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？</p>
<ul>
<li><p>display的属性值</p>
<pre><code>block 象块类型元素一样显示。
none 缺省值。象行内元素类型一样显示。
inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
list-item 象块类型元素一样显示，并添加样式列表标记。
</code></pre><ul>
<li>position的值</li>
<li><pre><code>*absolute
      生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

*fixed （老IE不支持）
      生成绝对定位的元素，相对于浏览器窗口进行定位。

*relative
      生成相对定位的元素，相对于其正常位置进行定位。
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>static 默认值。没有定位，元素出现在正常的流中*（忽略 top, bottom, left, right z-index 声明）。</li>
<li>inherit 规定从父元素继承 position 属性的值。</li>
</ul>
</li>
<li><p>CSS3有哪些新特性？</p>
<pre><code>CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），
</code></pre><p>   对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>   transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>   增加了更多的CSS选择器  多背景 rgba</p>
</li>
<li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</p>
<p>  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p>
</li>
<li><p>display:inline-block 什么时候会显示间隙?</p>
<p>  移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>
<h2>JavaScrpit</h2>
</li>
<li><p>说几条写JavaScript的基本规范？</p>
<pre><code>1. 不要在同一行声明多个变量。
2. 请使用 ===/!==来比较true/false或者数值
3. 使用对象字面量替代new Array这种形式
4. 不要使用全局函数。
5. Switch语句必须带有default分支
6. 函数不应该有时候有返回值，有时候没有返回值。
7. For循环必须使用大括号
8. If语句必须使用大括号
9. for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。
</code></pre></li>
</ul>
<ul>
<li><p>eval是做什么的？</p>
<pre><code>它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
</code></pre></li>
<li><p>Node.js的适用场景？</p>
<p>  高并发、聊天、实时消息推送</p>
</li>
<li><p>介绍js的基本数据类型。</p>
<pre><code>number,string,boolean,object,undefined
</code></pre></li>
<li><p>new操作符具体干了什么呢?</p>
<ol>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li><p>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<pre><code>var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre></li>
</ol>
</li>
<li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>
<pre><code>hasOwnProperty
</code></pre></li>
<li><p>JSON 的了解？</p>
<p>  JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>  它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</p>
</li>
<li><p>js延迟加载的方式有哪些？</p>
<p>  defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>
</li>
<li><p>如何解决跨域问题?</p>
<p>   jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p>
</li>
<li><p>documen.write和 innerHTML的区别</p>
<p>  document.write只能重绘整个页面</p>
<p>  innerHTML可以重绘页面的一部分</p>
</li>
</ul>
<p></p><h2> 对Node的优点和缺点提出了自己的看法？</h2><br> *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。<p></p>
<p> *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p>
<ul>
<li><p>你有哪些性能优化的方法？</p>
<pre><code>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

（4） 当需要设置的样式很多时设置className而不是直接操作style。

（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。
</code></pre></li>
<li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p>
<p>   查找浏览器缓存</p>
<p>  DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求</p>
<p>  进行HTTP协议会话</p>
<p>  客户端发送报头(请求报头)</p>
<p>  服务器回馈报头(响应报头)</p>
<p>  html文档开始下载</p>
<p>  文档树建立，根据标记请求所需指定MIME类型的文件</p>
<p>  文件显示<br>  [<br>  浏览器这边做的工作大致分为以下几步：</p>
<p>  加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。</p>
<p>  解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等）<br>  }</p>
</li>
<li><p>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</p>
<p>   前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p>
<ol>
<li>实现界面交互</li>
<li>提升用户体验</li>
<li>有了Node.js，前端可以实现服务端的一些事情</li>
</ol>
</li>
<li><p>平时如何管理你的项目？<br>  先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p>
<p>  编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</p>
<p>  标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</p>
<p>  页面进行标注（例如 页面 模块 开始和结束）；</p>
<p>  CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</p>
<p>  JS 分文件夹存放 命名以该JS功能为准的英文翻译。</p>
<p>  图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/webpack和gulp对比/" itemprop="url">
                  wekpack和gulp对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/webpack-gulp/" itemprop="url" rel="index">
                    <span itemprop="name">webpack gulp</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>Gulp和Webpack功能实现对比</h2><br>简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。<br><br><h3>基本概念</h3><br><br>首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重点是不同的。<br><br>Gulp侧重于前端开发的整个过程的<strong>控制管理</strong>（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。<br><br>Webpack有人也称之为<strong>模块打包机</strong>，由此也可以看出Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的。<br><br>另外我们知道Gulp是对整个过程进行控制，所以在其配置文件（gulpfile.js）中配置的每一个task对项目中该task配置路径下所有的资源都可以管理。<br>比如，对sass文件进行预编译的task可以对其配置路径下的所有sass文件进行预编译处理：<br><br>    gulp.task(‘sass’,function(){<br>        gulp.src(‘src/styles/<em>.scss’)<br>        .pipe(sass().on(‘error’,sass.logError))<br>        .pipe(gulp.dest(‘./build/prd/styles/‘));//编译后的输出路径<br>    });<br>上面这个task可以对’src/styles/</em>.scss’目录下的所有以.scss结尾的文件进行预处理。<br><br>Webpack则不是这样管理资源的，它是根据模块的<strong>依赖关</strong>系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><br>webpack通过依赖关系静态分析<br>通俗的说，Webpack就是需要通过其配置文件（webpack.config.js）中entry配置的一个入口文件（JS文件）,如下图<br><br>    entry: {<br>          app:<strong>dirname + “/src/scripts/app.js”,<br>    }<br>然后Webpack进入该app.js文件进行解析，app.js文件如下图：<br><br>    //引入scss文件<br>    import ‘../style/app.scss’;<br><br>    //引入依赖模块<br>    var greeter = require(‘./Greeter.js’);<br>    document.getElementById(‘root’).appendChild(greeter());<br><br>解析过程中，发现一个<code>app.scss</code>文件，然后根据<code>webpack.config.js</code>配置文件中的<code>module.loaders</code>属性去查找处理<code>.scss</code>文件的<code>loader</code>进行处理，处理<code>app.scss</code>文件过程中，如果发现该文件还有其他依赖文件，则继续处理<code>app.scss</code>文件的依赖文件，直至处理完成该“链路”上的依赖文件，然后又遇到一个<code>Greeter.js</code>模块，于是像之前一样继续去查找对应的loader去处理…<br>所以，Webpack中对资源文件的处理是通过入口文件产生的依赖形成的，不会像Gulp那样，配置好路径后，该路径下所有规定的文件都会受影响。<br><br><h3>模块化开发</h3><br><br>所谓的前端模块化开发，我的理解就是，在开发的时候，把不通的资源文件按照他的具体用途进行分类管理，在使用的时候利用CommonJS、AMD、CMD等规范将这些资源文件引入到当前文件中。然后在测试或者最后上线的时候，将这些资源文件按照一定的要求进行压缩合并再加上版本控制处理。<br>可能这样的理解或者说法值得商榷，但是个人还是觉得模块化就是对内容的管理，是为了解耦合。<br><br>首先从Gulp入手，看看在项目中，怎样利用模块化的思想进行开发。下面是一个gulp项目的目录结构：<br>gulp项目目录结构<br><br><br>Gulp<br><br> |——build:  项目输出路径<br> |    |——prd:  css、js文件输出路径<br> |        |——scripts: js文件的输出路径<br> |        |——styles: css文件的输出路径<br> |    |——ver: 版本号相关文件<br> |    |——index.html: 编译后的index.html<br> |——images: 图片文件夹<br> |——mock: mock数据文件夹<br> |——node_modules: npm包管理文件夹<br> |——src: 工作目录<br> |    |——scripts<br> |        |——libs: 第三方依赖库（jQuery等）<br> |        |——tpls: 模板文件<br> |        |——utils: 工具类文件夹<br> |        |——views: 页面自定义js文件<br> |        |——app.js: index.html文件的入口js<br> |    |——styles：文件和scripts文件夹下基本一致（本例中我引用了第三方框架，目录更深，不在展示）<br> |——gulpfile.js: gulp的配置文件<br> |——index.html: 主页html文件<br> |——package.json: npm包管理配置文件<br><br>在实际开发过程中，在src目录下工作，html、js和css等文件通过gulp的task配置，执行合并和压缩后输出到build目录下（下面会详细介绍合并压缩的实现）。在详细一点就是：<br><br>&gt;1. 创建主页html文件<br>&gt;2. 创建与之对应的app.js入口文件和app.scss入口文件。这两个文件只通过CommonJS规范引入各自views文件中自定义的js(或scss)文件，具体逻辑不写此文件中。<br>&gt;3. 在views目录下编写js（或css）文件的逻辑代码，其中如果多个文件需要公共逻辑或者工具方法，就可以抽离出来在util文件夹下创建对应的公共方法，然后在views中需要的js（或css）文件中通过CommonJS规范引入使用。libs目录下的第三方库或框架也是这个思想去引用。<br>&gt;4.scripts目录下的tpls文件是用来放置html模板的，引用方式和引用libs相同。<br>大体介绍了一下我理解的模块化的思想，但是需要指出的是Gulp对js文件的模块化工作是通过Webpack实现的，具体来说是通过安装gulp-webpack模块和相关的loader模块进行js模块化管理的。具体步骤如下：<br><br>1.在项目中通过npm安装一个gulp-webpack、vinyl-named、imports-loader和string-loader模块(压缩合并模块后面再介绍)<br><br>    $ npm install gulp-webpack vinyl-named -D<br>2.然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webpack 模块，并进行简单配置<br><br>       //1.引入 gulp-webpack和vinyl-named模块<br>      var webpack= require(‘gulp-webpack’);<br>      var webpack= require(‘vinyl-named’);<br>       //2.js 模块化配置<br>      var jsFiles = [<br>        ‘./src/scripts/*.js’,<br>      ];<br>      gulp.task(‘packjs’,function(){<br>    gulp.src(jsFiles)<br>    .pipe(uglify().on(‘error’,function(err){<br>       console.log(‘\x07’,err.lineNumber,err.message);<br>       return this.end();<br>     }))<br><br>    //Webpack 对js模块化部分 start<br>    .pipe(webpack({<br>        output:{<br>          filename:’[name].js’<br>        },<br>        module:{<br>            loaders:[{<br>              test: /.js$/,<br>              loader:’imports?define=&gt;false’<br>            },<br>            {<br>              test:/.string$/,<br>              loader:’string’<br>            }<br>          ]<br>        }<br>      }));<br>      //Webpack 对js模块化部分 end<br>    .pipe(concat(‘all.js’))<br>    .pipe(gulp.dest(‘./build/prd/scripts/‘));<br>});<br>对css文件我们也采用同js文件一样的模块化思想，利用sass进行模块化开发，至于对scss文件的合并压缩配置，下面还会详细介绍。<br><br>接下来应该介绍一下Webpack的模块化实现了，其实也就没什么可以说的了，文件目录和Gulp的基本相同，只不过实现过程中使用到的插件或者说模块不同，配置不同而已。另外需要注意的是，Webpack对于资源文件的模块化打包处理都是按js文件的处理方式处理的，例如还是上一小节中，你可能发现了，我在<code>app.js</code>入口文件中有这样一行代码<br><br>    import ‘../style/app.scss’;<br>你当时可能产生疑问，为什么在js文件中引入scss文件呢？<br>这是因为Webpack是通过依赖关系进行文件管理的，所以，想要对样式文件进行模块化管理则必须与<code>app.js</code>入口文件建立依赖关系，因此我们将样式文件的入口<code>app.scss</code>文件引入到了<code>app.j</code>s中（其他资源想要被管理，也需要这样与<code>app.js</code>入口文件建立依赖关系）。<br>但是这样做很明显的就是样式文件通过<code>app.js</code>入口文件全部都合并压缩到js文件中了，这很显然不是我们想要的结果，所以我们需要将样式文件从js文件中剥离出来。<br><br>  在项目中通过npm安装一个extract-text-webpack-plugin的模块<br><br>    $ npm install  extract-text-webpack-plugin -D<br>然后在Webpack的配置文件webpack.config.js中进行简单配置<br><br>     //1.引入extract-text-webpack-plugin模块<br>     var Et = require(‘extract-text-webpack-plugin’);<br>     module.exports = {<br>       //source-map调试<br>       devtool: ‘eval-source-map’,<br>       //webpack入口文件配置<br>       entry: {<br>       app:</strong>dirname + “/src/scripts/app.js”,<br>       },<br>       //webpack出口文件配置<br>       output: {<br>           path: <strong>dirname + “/prd/scripts/“,//输出文件路径配置<br>           filename: “bundle.js”//输出文件名配置<br>       },<br>       module:{<br>           loaders:[<br>             {<br>                 test: /.scss$/,<br>                 loader: Et.extract(‘style’,’css!sass’)//从js中抽离scss文件<br>             }<br>           ]<br>        },<br>       plugins: [<br>           new Et(‘./styles/bundle.css’),//从js中抽离scss文件输出目录设置<br>       ],<br>       //本地server配置<br>       devServer: {<br>         contentBase:  </strong>dirname + ‘/prd/‘,//本地服务器所加载的页面所在的目录<br>         port:8089,//本地服务端口配置<br>         colors: true,//终端中输出结果为彩色<br>         historyApiFallback: true,//不跳转<br>         inline: true//实时刷新<br>       }<br>    }<br>上面有些配置信息并不完全，下面的小节中会逐渐介绍到。这样我们就实现了将css文件从js文件中剥离出来的目的。Webpack不但可以对css文件可以进行模块化管理，还可以对图片进行模块管理，有兴趣的可以自己去尝试一下。<br><br><h2>文件合并与压缩</h2>

<p>上面的模块化中，我们提到了模块化其实很大一部分是在做文件的合并与压缩操作，所以我们马上来看看Gulp和Webpack是怎样是想文件的合并和压缩的。</p>
<p>先来看看大背景，由于现在前端越来越庞大，页面文件依赖也越来越多，所以对这些文件进行合理的合并和压缩就志在必得。根据前面的了解，Webpack应该比Gulp更擅长文件合并和压缩，毕竟人家被称为模块打包机吗。<br>结论是正确的，Gulp可以对css文件以及js文件进行合并压缩处理，而Webpack可以实现对css文件，js文件，html文件等进行合并压缩和图片的压缩，还可以对js文件进行编译（如es6–&gt;es5，react jsx）等等，这些都是通过Webpack的loader实现的，当然这些也可以加入到Gulp中，毕竟Gulp把Webpack当做一个模块，通过gulp-webpack都引入了。</p>
<h3>Gulp合并压缩文件</h3>

<p><strong>css的压缩</strong> </p>
<p>要想实现Gulp对css文件的压缩只需要安装一个gulp-minify-css模块即可。</p>
<p>  在项目中通过npm安装一个gulp-minify-css的模块</p>
<pre><code>$ npm install gulp-minify-css -D
</code></pre><p>  然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-minify-css模块，并进行简单配置</p>
<pre><code> //1.引入 gulp-minify-css模块
var minifyCSS = require(&apos;gulp-minify-css&apos;);
//2.css 预处理
var cssFiles = [
  &apos;./src/styles/usage/page/index.scss&apos;
]
gulp.task(&apos;sass&apos;,function(){
    gulp.src(cssFiles)
    .pipe(sass().on(&apos;error&apos;,sass.logError))
    .pipe(minifyCSS())//执行压缩处理在一行
    .pipe(gulp.dest(&apos;./build/prd/styles/&apos;));
});
</code></pre><p>这样一个简单的css压缩就实现了。</p>
<p><strong>js合并压缩</strong></p>
<p>要想实现Gulp对js文件的合并压缩需要安装一个gulp-uglify和gulp-concat两个模块，前者是用于压缩的模块，后者是一个合并的模块。</p>
<p>  在项目中通过npm安装gulp-uglify和gulp-concat模块</p>
<pre><code>$ npm install gulp-uglify gulp-concat -D
</code></pre><p>  然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-uglify和gulp-concat模块，并进行简单配置</p>
<pre><code> //1.引入**gulp-uglify**和**gulp-concat**模块
 var uglify = require(&apos;gulp-uglify&apos;);
 var concat = require(&apos;gulp-concat&apos;);
//js 合并压缩
 var jsFiles = [
    &apos;./src/scripts/*.js&apos;,
  ];
  gulp.task(&apos;packjs&apos;,function(){
    gulp.src(jsFiles)
    //js文件的压缩
    .pipe(uglify().on(&apos;error&apos;,function(err){
       console.log(&apos;\x07&apos;,err.lineNumber,err.message);
       return this.end();
     }))
    .pipe(webpack({
        output:{
          filename:&apos;[name].js&apos;
        },
        module:{
            loaders:[{
              test: /\.js$/,
              loader:&apos;imports?define=&gt;false&apos;
            },
            {
              test:/\.string$/,
              loader:&apos;string&apos;
            }
          ]
        }
      }));
    //js文件的合并
    .pipe(concat(&apos;all.js&apos;))
    .pipe(gulp.dest(&apos;./build/prd/scripts/&apos;));
});
</code></pre><p>js的文件合并压缩也完成了。我们再来看一下Webpack的合并压缩。</p>
<h3>Webpack的合并压缩</h3>

<p><strong>压缩js和css</strong></p>
<p>针对js和css文件的压缩，Webpack已经内嵌了uglifyJS来完成对js与css的压缩混淆，无需引用额外的插件。我们只需要在Webpack配置文件中的plugins属性中做如下配置：</p>
<pre><code>  plugins: [
    new webpack.optimize.UglifyJsPlugin({ //压缩代码
      compress: {
        warnings: false
      },
      except: [&apos;$super&apos;, &apos;$&apos;, &apos;exports&apos;, &apos;require&apos;] //排除关键字
  })
]
</code></pre><p>需要注意的是：压缩的时候需要排除一些关键字，不能混淆，比如$或者require，如果混淆的话就会影响到代码的正常运行。</p>
<h3>html的压缩</h3>

<p>想要对html进行压缩，同样也是需要配置Webpack的配置文件，并且需要下载两个插件HtmlWebpackPlugin和html-minifier插件：<br>1.在项目中通过npm安装HtmlWebpackPlugin和html-minifier模块</p>
<pre><code>$ npm install HtmlWebpackPlugin -D
$ npm install html-minifier -D
</code></pre><p>2.然后在Webpack的配置文件webpack.config.js进行如下配置：</p>
<pre><code>plugins: [
   new HtmlWebpackPlugin({ //根据模板插入css/js等生成最终HTML
       favicon:&apos;./src/img/favicon.ico&apos;, //favicon路径
       filename:&apos;/view/index.html&apos;, //生成的html存放路径
       template:&apos;./src/view/index.html&apos;, //html模板路径
       inject:true, //允许插件修改哪些内容，包括head与body
      hash:true, //为静态资源生成hash值
      minify:{ //压缩HTML文件
          removeComments:true, //移除HTML中的注释
           collapseWhitespace:true //删除空白符与换行符
       }
  })
 ]
</code></pre><p>HtmlWebpackPlugin插件在生成HTML时调用了 html-minifier 插件来完成对HTML的压缩，这里我们使用两个配置完成来移除HTML中的注释以及空白符达到压缩的效果。</p>
<h3>sass/less预编译</h3>

<p>我们再来看看<code>sass/less</code>预编译，其实就<code>sass/less</code>的预编译来说，两者区别不是很大。Gulp是通过g<code>ulp-sass、gulp-less</code>模块进行预处理；而Webpack是通过<code>scss-loader、less-loader</code>加载器（loader）进行预处理。我们还是分别来看一下两者对此的实现。</p>
<h3>Gulp预编译sass/less</h3>

<p>以sass为例子：</p>
<p>在项目中通过npm安装一个gulp-sass的模块</p>
<pre><code>$ npm install gulp-sass -D
</code></pre><p>然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-sass模块，并进行简单配置</p>
<pre><code> //1.引入 gulp-sass模块
var sass= require(&apos;gulp-sass&apos;);
//2.css 预处理
var cssFiles = [
  &apos;./src/styles/usage/page/**/*&apos;
  //./src/styles/usage/page目录下的所有文件
];
gulp.task(&apos;sass&apos;,function(){
    gulp.src(cssFiles)
    .pipe(sass().on(&apos;error&apos;,sass.logError))
    .pipe(minifyCSS())
    .pipe(gulp.dest(&apos;./build/prd/styles/&apos;));//编译后的输出路径
});

//3.对sass文件的修改添加监听事件
gulp.task(&apos;watch&apos;,function(){
   gulp.watch(&apos;./src/styles/**/*&apos;,[&apos;sass&apos;]);
});
gulp.task(&apos;default&apos;,[&apos;watch&apos;,&apos;webserver&apos;],function(){
    console.log(&apos;所有任务队列执行完毕&apos;);
});
</code></pre><p>这样，一个简单的sass预处理的task就配置完成了，然后我们还将该task加到gulp.watch()上实现了自动编译（即修改sass文件后保存，则立即执行sass预处理），配合Gulp启动的server则可以实现sass文件修改保存即可在浏览器中查看效果的目的，下一小节会介绍启动本地server。</p>
<h3>Webpack预编译sass/less</h3>

<p>同样以sass为例子：</p>
<p>在项目中通过npm安装一个sass-loader和node-sass模块，前者是用来加载sass相关文件的，后者是用来编译sass文件的。另外还需要安装另外两个模块css-loader和style-loader，前者是用来加载css相关文件的，后者是用来将css样式装填到html中的内联样式。</p>
<pre><code>$ npm install sass-loader node-sass css-loader style-sass -D
</code></pre><p>然后在Webpack的配置文件webpack.config.js中进行简单配置</p>
<pre><code> module:{
      loaders:[
      {
          test: /\.css$/,//匹配以.css结尾的文件，如果你项目不需要刻意不配置
          loader: &apos;style!css&apos;//这里顺序必须这样  
      },
      {
          test: /\.scss$/,//匹配以.scss结尾的文件
          loader: &apos;style!css!sass&apos;
      }
    ]
}
</code></pre><p>前面提到过，Webpack是通过文件的依赖关系进行加载分析的，所以当程序从主入口（js文件）进入后，在依赖的资源文件中发现有sass文件后，就会利用我们配置的sass-loader去加载，然后用node-sass去解析编译成普通的css语法的样式文件，在然后就是利用style-loader将样式以内联样式的形式配置到html中（这里有一个问题，就是css-loader有什么用?我也没搞明白，但是不添加会报错，有知道的可以留言交流一下）。这样Webpack就完成了sass的预处理。</p>
<h3>启动server</h3>

<p>我们都知道在前端开发中，ajax请求是需要启动一个server的。特别是在前后端分离思想中，前端开发不再像以前一样过分依赖于后端开发，以前的那种前端测试ajax请求需要装个tomcat或者其它服务器来启动server的现象已经成为过去式，现在我们可以使用像Gulp这类前端自动构建工具启动一个本地server进行测试，再也不收后端程序员钳制了（开个玩笑，和后端好好沟通才能让前端开发更方便）。那么，我们来分别看一下Gulp和Webpack是怎样实现这个功能的。</p>
<h3>Gulp启动server</h3>

<p>在Gulp中想要启动一个本地serve，只需要以下几步：</p>
<p>在项目中通过npm安装一个gulp-webserver的模块</p>
<pre><code>$ npm install gulp-webserver -D
</code></pre><p>然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webserver模块，并进行简单配置</p>
<pre><code> //1.引入 gulp-webserver 模块
var webserver = require(&apos;gulp-webserver&apos;);
//2.配置server task
gulp.task(&apos;webserver&apos;,function(){
  gulp.src(&apos;./&apos;)
  .pipe(webserver({
      host:&apos;localhost&apos;,
      port:80,
      //浏览器自动刷新
      livereload:true,
      //显示文件目录
      directoryListing:{
        enable: true,
        path:&apos;./&apos;
      },
    }));
});
//3.配置默认task
gulp.task(&apos;default&apos;,[&apos;webserver&apos;],function(){
    console.log(&apos;启动任务队列执行完毕&apos;);
})
</code></pre><p>在命令行中启动server</p>
<pre><code>$ gulp
</code></pre><p>启动成功：</p>
<pre><code>gulp cli 启动成功
</code></pre><p>在浏览器地址栏中输入localhost打开页面验证。<br>经过以上这三步，我们就在Gulp中启动了一个server了。在Gulp中启动本地服务有一个很方便的配置，就是<code>livereload:true</code>属性的设置，设置后浏览器会根据你项目中资源的变化自动刷新浏览器（如果你的chrome浏览器设置该属性后在你修改文件并保存时仍没有自动刷新，可能是你的chrome浏览器不支持，可以chrome扩展程序中搜索并安装LiveReload插件），比如：<br>我的gulp测试目录结构：<br>gulp测试目录结构</p>
<p>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Document&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;script src=&quot;/src/scripts/app.js&quot;&gt;&lt;/script&gt;
 &lt;/body&gt;
</code></pre><p><br>我在app.js文件中输入以下内容，然后保存。</p>
<pre><code>console.log(&apos;gulp-webserver livereload&apos;);
</code></pre><p>浏览器中控制台上会立刻打印出一下信息：<br>gulp测试目录结构<br>说明浏览器自动刷新工程，这个小功能在我们开发中屡试不爽。但是，这个功能是需要结合上一小节中的<code>gulp.watch()</code>实时监控文件变化，然后执行合并压缩和<code>sass/less</code>编译等操作后，浏览器再刷新时才能保证是我们修改后的内容。所以，<code>livereload:tru</code>e属性只是监控到我们修改文件后刷新浏览器重新请求文件，如果我们不重新编译修改后的文件，浏览器获取到的还是原文件，并不会展示变化。</p>
<h3>Webpack启动server</h3>

<p>在Webpack中也可以通过插件的形式安装一个webpack-dev-server来实现达到启动本地server的目的，具体步骤如下：</p>
<p>在项目中通过npm安装一个webpack-dev-server的模块</p>
<pre><code>$ npm install  -g webpack-dev-server -D
</code></pre><p>然后在Webpack的配置文件webpack.config.js中进行简单配置</p>
<pre><code> module.exports = {
   devtool: &apos;eval-source-map&apos;,
   //webpack入口文件配置
   entry: {
   app:__dirname + &quot;/src/scripts/app.js&quot;,
   },
   //webpack出口文件配置
   output: {
       path: __dirname + &quot;/prd/scripts/&quot;,//输出文件路径配置
       filename: &quot;bundle.js&quot;//输出文件名配置
   },
   //本地server配置
   devServer: {
     contentBase:  __dirname,//本地服务器所加载的页面所在的目录
     port:8089,//本地服务端口配置
     colors: true,//终端中输出结果为彩色
     historyApiFallback: true,//不跳转
     inline: true//实时刷新
   }
}
</code></pre><p>在命令行中启动server</p>
<pre><code>$ webpack-dev-server
</code></pre><p>然后你就会看见命令行输出内容很多，只要看看保证没有Error就说明成功了。</p>
<p> 在浏览器地址栏中输入localhost：8089测试一下。<br>Webpack的启动本地服务也顺利实现了，是不是也想实现像Gulp一样浏览器自动刷新呀？那Webpack能不能实现呢？答案是肯定的，Webpack官方提供了一个辅助开发工具，它可以自动监控项目下的文件，一旦有修改保存操作，开发服务器就会自动运行Webpack 打包命令，帮我们自动将开发的代码重新打包。而且，如果需要的话，还能自动刷新浏览器，重新加载资源。理论上好像是这样，但是实现好像有不少限制，比如，HTML文件的自动刷新问题（html-webpack-plugin插件使用老是报错），当本地server启动在非output.path路径之外时则不能自动刷新等问题。</p>
<p>而这个辅助工具就是<code>webpack-dev-server</code>，它主要提供两个功能：一是为静态文件提供server服务，二是自动刷新和热替换(HMR)。所以想实现如Gulp一样的功能也是可以的，只需要在<code>$ webpack-dev-server</code>后面添加<code>--inline --hot</code>即可。需要注意的是–inline是自动刷新，同时在第二部中的devServer属性中有一个inline:true需要配置；而–hot是热替换（详细了解热替换、了解<code>webpack-dev-server、webpack-dev-server）</code>。</p>
<p>通过对比来看，好像Webpack的<code>webpack-dev-server</code>比Gulp的<code>gulp-server</code>功能要强一些。因为通过上面可以看出webpack-dev-server有两个大功能：一是为静态文件提供server服务，二是自动刷新（自动刷新其实需要两步：1.修改文件后，文件自动编译{包括合并压缩或者语法编译等}，2.刷新浏览器请求最新编译后的文件）和热替换(HMR)；而gulp-server虽然提供了启动本地server的能力和仅自动刷新浏览器的能力，缺少一个文件自动编译的能力，这需要借助其他模块实现（上一小节已介绍，结合gulp.watch()实时监控文件变化，并编译）。</p>
<p>另外需要注意的是，实际开发中发现<code>webpack-dev-server</code>实现自动刷新的时候，并没有执行自动编译，只是将修改的内容合并压缩等处理后发送给了浏览器，并造成了已经编译的现象，但是通过<code>build/prd/scripts</code>目录下的<code>bundle.js</code>(合并压缩后的输出文件)文件，可以发现内容并没有编译（对于Webpack还是不熟悉，好多问题等待解决）。</p>
<h3>mock数据</h3>

<p>在现在前后端分离的思想中，前端和后端耦合度越来越小，现在唯一需要前后端密切联系的就是借口的定义和数据格式的确定。一般在项目开始前，前端和后端将项目中的接口和数据格式全部确定下来（当然项目需求变更就需要临时确立这些共识了），然后前端就可以自己mock数据了。</p>
<h3>Gulp实现mock数据</h3>

<p>Gulp中对mock数据的实现使通过NodeJS内置的fs模块和url模块实现的，因为Gulp本身就是基于NodeJS的。还记得第一小节“模块化开发”中目录结构中的那个mock目录吗？那就是用来储存.json文件的mock数据目录。</p>
<blockquote>
<p>配置Gulp的gulpfile.js文件</p>
</blockquote>
<pre><code>//1.引入 fs 和 url 模块
var fs = require(&apos;fs&apos;);
var url = require(&apos;url&apos;);
//2.重新配置一下上一小节的server
gulp.task(&apos;webserver&apos;,function(){
   gulp.src(&apos;./&apos;)
   .pipe(webserver({
      host:&apos;localhost&apos;,
      port:80,
      livereload:true,
      directoryListing:{
        enable: true,
        path:&apos;./&apos;
    },
    //mock数据配置
    middleware:function(req,res,next){
      var urlObj = url.parse(req.url,true);
      switch (urlObj.pathname) {
          case &apos;/pro/getPro&apos;:
            res.setHeader(&apos;Content-Type&apos;,&apos;application/json;charaset=utf-8&apos;);
            fs.readFile(&apos;./mock/list.json&apos;,function(err,data){
              //上面list.json路径使用相对路径，绝对路径前台无法获取数据
              res.end(data);
            });
            return;
          case &apos;/web/getUser&apos;:
              //....
            return;
        }
        next();
      }
    }));
});
</code></pre><p>具体来说，就是通过NodeJS拦截http请求，根据请求URL来模拟后端做出处理后返回不同的数据。</p>
<h3>版本控制</h3>

<p>对于版本控制，我们在开发过程中，也是一个使用比较频繁的功能，特别是开发团队比较大的时候，这个功能就显得更加重要了。那么Gulp和Webpack是具体怎样实现的呢？</p>
<h3>Gulp实现版本控制</h3>

<p>在项目中通过npm安装gulp-rev和gulp-rev-collector模块，前者用于生成文件的MD5码文件和按MD5码命名的资源文件，后者是利用MD5码，对文件名进行替换。</p>
<pre><code>$ npm install  gulp-rev gulp-rev-collector -D
</code></pre><p>然后在Gulp的配置文件gulpfile.js中进行简单配置</p>
<pre><code>  //1.引入连个模块
  var rev = require(&apos;gulp-rev&apos;);
  var revCollector = require(&apos;gulp-rev-collector&apos;);
  // 2.版本号控制
  gulp.task(&apos;ver&apos;,function(){
    gulp.src(cssFiles)
    .pipe(rev())//产生MD5码
    .pipe(gulp.dest(&apos;./build/prd/styles/&apos;))//重命名文件
    .pipe(rev.manifest())//产生版本信息的json文件
    .pipe(gulp.dest(&apos;./build/ver/styles/&apos;));
  gulp.src(jsFiles)
  .pipe(rev())
  .pipe(gulp.dest(&apos;./build/prd/scripts/&apos;))
  .pipe(rev.manifest())
  .pipe(gulp.dest(&apos;./build/ver/scripts/&apos;));
 })
 //动态修改html中对css和js文件的修改
 gulp.task(&apos;html&apos;,function(){
  gulp.src([&apos;./build/ver/**/*&apos;,&apos;./build/*.html&apos;])
  .pipe(revCollector())
  .pipe(gulp.dest(&apos;./build/&apos;));
})
</code></pre><p>Gulp实现版本控制很方便，将这两个task加入<code>gulp.watch()</code>中，即可实现修改保存文件实时自动修改版本的功能。</p>
<p>Webpack实现版本控制</p>
<p>Webpack中需要版本控制的有<code>css、js</code>文件，不过Webpack的版本控制只实现了将<code>css、js</code>文件添加hash值方式命名的文件方式，修改引用路径中的文件名需手动实现。<br>不过实现确实很简单，只需要将<code>webpack.config.js</code>配置文件中的<code>output.filename</code>和<code>plugins</code>中的输出文件名称修改一下即可。</p>
<pre><code>module.exports = {
    devtool: &apos;eval-source-map&apos;,
    entry: {
    app:__dirname + &quot;/src/scripts/app.js&quot;,
    },
    output: {
        path: __dirname + &quot;/prd/scripts/&quot;,
        filename: &quot;[name]-[hash].js&quot;//修改输出文件名
    },
    plugins: [
        new Et(&apos;./styles/[name]-[hash].css&apos;),//修改输出文件名
    ]
 }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/vue--webpack/" itemprop="url">
                  vue+webpack环境的搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##vue 环境的搭建</p>
<p>在搭建的babel的基础上，在安装string-loader</p>
<p>vuex用于实现定义全局变量和对其管理</p>
<p>自定义组件：可以把css和js定义一个组件</p>
<p>##webpack环境的搭建</p>
<ol>
<li><p><code>cnpm i webpack -g</code>全局安装</p>
</li>
<li><p><code>cnpm i webpack -D</code>本地安装</p>
</li>
<li><p><code>webpack entry.js  bundle.js</code>(把entry.js编译成bundle.js) </p>
</li>
<li><p><code>cnpm i css-loader style-loader -D</code>(加载css文件)</p>
</li>
<li><p>配置webpack的配置文件</p>
</li>
<li><p><code>cnpm i webpack --devtool source-map -D</code>打开文件树</p>
</li>
<li><p><code>cnpm i webpack-dev-server -g</code>全局安装(webpack的服务)</p>
</li>
<li><p><code>cnpm i webpack-dev-server -D</code>本地安装</p>
<p>9.<code>webpack-dev-server --inline --hot -D</code>(监听，可以写到package.json中的build中)</p>
</li>
<li><p><code>cnpm i babel-loader babel-preset-es2015 babel-core babel-preset-react -D</code></p>
</li>
<li><code>cpnm i json-server -g</code>全局安装  用于mock数据(json-server ‘mock的路径’ –port 8888)；</li>
</ol>
<p><mark>注意：在安装的过程中发生的错误，一般都是网络的原因引起的，在失败之后可以尝试重新安装</mark></p>
 <h2>项目的初始化</h2>

<ul>
<li>新建一个项目的名称</li>
<li>进入文件夹下，执行npm init 对项目初始化</li>
<li><ol>
<li><p><code>cnpm i webpack -g</code>全局安装</p>
</li>
<li><p><code>cnpm i webpack -D</code>本地安装<br>安装完成后可以通过 webpack 待编译的js名称 编译后的js名称(例如：webpack entry.js  bundle.js)</p>
</li>
</ol>
</li>
<li><ol>
<li><code>cnpm i css-loader -D</code></li>
<li><code>cnpm i style-loader -D</code></li>
<li>通过1和2实现css的样式的加载</li>
<li><p>配置webpack的配置文件<br><strong>具体代码：</strong></p>
<pre><code>module.exports={
   //webpack的入口文件
   entry:&apos;./entry.js&apos;,
   //输出的文件夹目录
   output:{
      path:__dirname,
      filename:&apos;bundle.js&apos;
   },
   //网页上的scurces下显示的webpack://下的内容
   devtool:&apos;source-map&apos;,
   //输出文件夹的目录
   module:{
      loaders:[
         {
            //选择要编译的文件类型
            test:/\.css$/,
            //对css类文件的编译格式
            loader:&apos;style!css&apos;
         }
      ]
   }
}
</code></pre><p>可参照网址：<a href="http://www.jianshu.com/p/42e11515c10f" title="webpack配置网址" target="_blank" rel="external">http://www.jianshu.com/p/42e11515c10f</a></p>
</li>
<li><p><code>cnpm i webpack --devtool source-map -D</code>打开文件树</p>
</li>
<li><p><code>cnpm i webpack-dev-server -g</code>全局安装(webpack的服务)</p>
</li>
<li><p><code>cnpm i webpack-dev-server -D</code>本地安装</p>
</li>
<li><p><code>webpack-dev-server --inline --hot -D</code>(监听，可以写到package.json中的build中)</p>
</li>
<li><p><code>cnpm i babel-loader babel-preset-es2015 babel-core babel-preset-react -D</code></p>
</li>
<li>全部安装完成之后通过 w<code>ebpack-dev-server --inline --hot</code>启动服务</li>
</ol>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/ui-router的使用/" itemprop="url">
                  ui-router的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/angular/" itemprop="url" rel="index">
                    <span itemprop="name">angular</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>首先要引入在<code>index.html</code>中引入<code>angular-ui-router.min.js</code>。</li>
<li>在angular.module(‘myApp’,[‘ui.router’]);中注入ui.router依赖。</li>
<li>配置路由：</li>
</ol>
<pre><code>myApp.config([&apos;$stateProvider&apos;,function($stateProvider) {
   $stateProvider
   .state(&apos;home&apos;,{
      url:&apos;/home&apos;,
      templateUrl:&apos;/src/scripts/tpls/ui-router/home.html&apos;,
      controller:&apos;homeController&apos;,
      controllerAs:&apos;homeCtrl&apos;,
      data:{
         customData:&apos;home自定义数据&apos;
      }
   })
    .state(&apos;employeeParent.employeeDetail&apos;, {
      url: &apos;/:id&apos;,
      templateUrl: &apos;/src/scripts/tpls/ui-router/employeedetail.html&apos;,
      controller: &apos;employeeDetailController&apos;
    })
    .state(&apos;employeeSearch&apos;, {
      url: &apos;/employeeSearch/:keywords&apos;,
      templateUrl: &apos;/src/scripts/tpls/ui-router/employeeSearch.html&apos;,
      controller: &apos;employeeSearchController&apos;
    })
}]);
</code></pre><p>和ng-router不同的是，ui-router用的是<code>$stateProvider</code>的依赖注入<br>在配置的时候用的是<code>.state</code>进行配置,对于otherwiae的配置可以放在外面单独配置：</p>
<pre><code>myApp.config(function ($urlRouterProvider) {
   $urlRouterProvider.otherwise(&apos;/home&apos;);
});
</code></pre><ol>
<li>ui-router的加载路由的标签是 <code>&lt;ui-view&gt;&lt;/ui-view&gt;</code></li>
</ol>
<p>具体的代码如下:（demo1.string)</p>
<pre><code>var demoTpl = require(&apos;../tpls/demo1.string&apos;);
var commonUtil = require(&apos;../utils/common.util.js&apos;);
commonUtil.render(demoTpl);

var myApp=angular.module(&apos;myApp&apos;,[&apos;ui.router&apos;]);

myApp.config(function ($urlRouterProvider) {
   $urlRouterProvider.otherwise(&apos;/home&apos;);
});

myApp.config([&apos;$stateProvider&apos;,function($stateProvider) {
   $stateProvider
   .state(&apos;home&apos;,{
      url:&apos;/home&apos;,
      templateUrl:&apos;/src/scripts/tpls/ui-router/home.html&apos;,
      controller:&apos;homeController&apos;,
      controllerAs:&apos;homeCtrl&apos;,
      data:{
         customData:&apos;home自定义数据&apos;
      }
   })
   .state(&apos;course&apos;,{
      url:&apos;/course&apos;,
      templateUrl:&apos;/src/scripts/tpls/ui-router/course.html&apos;,
      controller:&apos;courseController&apos;,
      controllerAs:&apos;courseCtrl&apos;,
      data:{
         customData:&apos;course自定义数据&apos;
      }
   })
   .state(&apos;employeeParent&apos;, {
      url: &apos;/employee&apos;,
      templateUrl: &apos;/src/scripts/tpls/ui-router/employeeParent.html&apos;,
      controller: &apos;employeeParentController&apos;
    })
    .state(&apos;employeeParent.employee&apos;, {
      url: &apos;/&apos;,
      templateUrl: &apos;/src/scripts/tpls/ui-router/employee.html&apos;,
      controller: &apos;employeeController&apos;,
      controllerAs: &apos;employeeCtrl&apos;,
      resolve: {
        employeelist: function($http) {
          return $http.get(&apos;/mock/employee.json&apos;).then(function(res){
            return res.data.data;
          });
        }
      }
    })
    .state(&apos;employeeParent.employeeDetail&apos;, {
      url: &apos;/:id&apos;,
      templateUrl: &apos;/src/scripts/tpls/ui-router/employeedetail.html&apos;,
      controller: &apos;employeeDetailController&apos;
    })
    .state(&apos;employeeSearch&apos;, {
      url: &apos;/employeeSearch/:keywords&apos;,
      templateUrl: &apos;/src/scripts/tpls/ui-router/employeeSearch.html&apos;,
      controller: &apos;employeeSearchController&apos;
    })
}]);


myApp.controller(&apos;homeController&apos;, [&apos;$scope&apos;, &apos;$rootScope&apos;, &apos;$state&apos;, function($scope, $rootScope, $state){
  $scope.message = &apos;home page&apos;;
  $scope.customData2 = $state.get(&apos;course&apos;).data.customData;
  $scope.customData1 = $state.current.data.customData;
}]);

myApp.controller(&apos;courseController&apos;, [&apos;$scope&apos;, &apos;$rootScope&apos;, function($scope, $rootScope){
  var vm  = this;
  vm.courses = [&apos;html5&apos;, &apos;java&apos;, &apos;android&apos;, &apos;iOS&apos;];
  $rootScope.color = &apos;red&apos;;
}]);

myApp.controller(&apos;employeeController&apos;, [&apos;$scope&apos;, &apos;$state&apos;, &apos;$rootScope&apos;, &apos;employeelist&apos;, function($scope, $http, $state, $rootScope, employeelist){
  var vm  = this;
  vm.keywords = &quot;&quot;;
  vm.search = function() {
    if (vm.keywords) {
      console.log($state);
      $state.go(&apos;employeeSearch&apos;, {
        keywords: vm.keywords
      })
    }
  };
  vm.reload = function() {
    $state.reload();
  };

  vm.employees = employeelist;
}]);

myApp.controller(&apos;employeeDetailController&apos;,[&apos;$scope&apos;,&apos;$stateParams&apos;,&apos;$http&apos;,function($scope,$stateParams,$http) {
   $http({
      url:&apos;/mock/employeedetail.json&apos;,
      params:{
         id:$stateParams.id
      }
   })
   .then(function (res) {
      $scope.employee=res.data.data[0];
   })
}]);

myApp.controller(&apos;employeeSearchController&apos;, [&apos;$scope&apos;, &apos;$stateParams&apos;, function($scope, $stateParams){
  $scope.keywords = $stateParams.keywords;
}]);

myApp.controller(&apos;employeeParentController&apos;, function($scope){
  ;
});
</code></pre><p>demo1.string的具体代码：</p>
<pre><code>&lt;table border=&quot;1&quot;&gt;
  &lt;tr&gt;
    &lt;td colspan=&quot;2&quot;&gt;header&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&quot;leftMenu&quot;&gt;
      &lt;a ui-sref=&quot;home&quot;&gt;home&lt;/a&gt;
      &lt;a ui-sref=&quot;course&quot;&gt;course&lt;/a&gt;
      &lt;a ui-sref=&quot;employeeParent.employee&quot;&gt;employee&lt;/a&gt;
    &lt;/td&gt;
    &lt;td class=&quot;mainContent&quot;&gt;
      &lt;ui-view&gt;&lt;/ui-view&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td colspan=&quot;2&quot; class=&quot;footer&quot;&gt;footer&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/rem实现原理/" itemprop="url">
                  rem的实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/移动端布局/" itemprop="url" rel="index">
                    <span itemprop="name">移动端布局</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##rem自适应布局的回顾总结</p>
<p><strong>rem自适应原理</strong></p>
<p>rem是根据html的font-size大小来变化，正是基于这个出发，我们可以在每一个设备下根据设备的宽度设置对应的html字号，从而实现了自适应布局。</p>
<p><strong>具体的实现方法</strong></p>
<ul>
<li><p><strong>使用媒体查询的方法</strong></p>
<ul>
<li><p>js方式<br>###获取移动设备宽高的方法：</p>
<p>  document.documentElement.clientWidth;<br>  document.documentElement.clientHeight;</p>
</li>
<li><p>媒体查询来调整字号</p>
<pre><code>@media only screen and (min-width: 481px) {
html {
font-size:94%!important
}
}

@media only screen and (min-width: 561px) {
html {
font-size:109%!important
}
}

@media only screen and (min-width: 641px) {
html {
font-size:125%!important
}
</code></pre></li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/nginx的基本配置/" itemprop="url">
                  nginx代理的基本配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/nginx/" itemprop="url" rel="index">
                    <span itemprop="name">nginx</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##nginx的使用</p>
<ul>
<li>首先安装nginx</li>
<li>用命令行在安装的nginx的目录下通过输入nginx可以启动nginx的服务</li>
<li>修改配置文件</li>
<li>找到conf文件夹 找到nginx.conf并打开，之后  把server中的内容都注释掉;</li>
<li><pre><code>#user  nobody;
# user root owner;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;
</code></pre></li>
</ul>
<pre><code>    events {
        worker_connections  1024;
    }


    http {
        include       mime.types;
        default_type  application/octet-stream;

        #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
        #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
        #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

        #access_log  logs/access.log  main;

        sendfile        on;
        #tcp_nopush     on;

        #keepalive_timeout  0;
        keepalive_timeout  65;

        #gzip  on;

        include D:/nginx/conf/conf.d/*.conf;这是配置自定义的conf的的内容，引入的是conf.d下的所有的以.conf结尾的配置文件

       #  server {
       #      listen       8080;
       #      server_name  localhost;
       #
       #      #charset koi8-r;
       #
       #      #access_log  logs/host.access.log  main;
       #
       #      location / {
       #          root   html;
       #          index  index.html index.htm;
       #      }
       #
       #      #error_page  404              /404.html;
       #
       #      # redirect server error pages to the static page /50x.html
       #      #
       #      error_page   500 502 503 504  /50x.html;
       #      location = /50x.html {
       #          root   html;
       #      }
       #
       #      # proxy the PHP scripts to Apache listening on 127.0.0.1:80
       #      #
       #      #location ~ \.php$ {
       #      #    proxy_pass   http://127.0.0.1;
       #      #}
       #
       #      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
       #      #
       #      #location ~ \.php$ {
       #      #    root           html;
       #      #    fastcgi_pass   127.0.0.1:9000;
       #      #    fastcgi_index  index.php;
       #      #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
       #      #    include        fastcgi_params;
       #      #}
       #
       #      # deny access to .htaccess files, if Apache&apos;s document root
       #      # concurs with nginx&apos;s one
       #      #
       #      #location ~ /\.ht {
       #      #    deny  all;
       #      #}
       #  }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
</code></pre><p>在server的上面添加如下代码：</p>
<pre><code>include D:/nginx/conf/conf.d/*.conf;这是配置自定义的conf的的内容，引入的是conf.d下的所有的以.conf结尾的配置文件
</code></pre><p>conf.d文件夹是自己创建的</p>
<ul>
<li><p>在conf.d的文件夹下创建一个以.conf结尾的文件，本例中创建的是hello.conf</p>
<pre><code>server{
   listen 8080;//启动服务的端口号
   server_name hello.dev;//服务的名子

   location / {
    “/”代表直接进入的路径，在浏览器输入：hello.dev即可
      root D:/HBuilder/bootstrap/back;//配置要加载的路径信息
      index index.html idex.htm;//这是在上面路径下的index.html
   }
   location /v2 {
    //在浏览器输入：hello.dev/v2,创建一个v2的文件夹，
      root D:/HBuilder/bootstrap/back;
      index index.html idex.htm;
   }
   location \.(jpg|gif|png)$ {
      expires 30d;
   }
   location /api {
    /配置反向代理服务，在浏览器输入hello.dev/api，它会自动走下边的代理路径，之后要配置代理的服务器
      proxy_pass http://api.hello.dev;
   }
}
</code></pre><p>新建一个名为api.conf的文件夹，进行如下配置</p>
<pre><code>server{
   listen 8080;
   server_name api.hello.dev;
   //要代理的内容在D:/nginx/mock路径之下，这样即可实现代理，实现数据的加载
   root D:/nginx/mock;
   index list.json;
}
</code></pre></li>
</ul>
<p>注意:(在启动服务之前要配置host，本例中配置的host如下：）</p>
<pre><code>127.0.0.1        hello.dev
127.0.0.1        api.hello.dev
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/ionic环境的配置/" itemprop="url">
                  ionic是基本环境依赖和环境配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iconic/" itemprop="url" rel="index">
                    <span itemprop="name">iconic</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###基本环境的配置</p>
<p>####安装依赖</p>
<ol>
<li>angular</li>
<li>cordova</li>
<li>gulp <a href="http://gulpjs.com" target="_blank" rel="external">http://gulpjs.com</a></li>
<li>nodejs</li>
<li>Bower<a href="http://bower.io" target="_blank" rel="external">http://bower.io</a></li>
<li>git </li>
<li>ionic</li>
</ol>
<p><strong>ionic具体包含：</strong></p>
<ul>
<li>css Compoments</li>
<li>js</li>
</ul>
<p><strong>具体的安装</strong></p>
<ul>
<li>cnpm i ionic -g</li>
<li>ionic -v(查看是否安装成功)</li>
<li>创建一个放置项目的文件夹</li>
<li>ionic start myApp(创建一个ionic的项目)</li>
<li>进入项目目录</li>
<li>ionic serve(启动服务，可以在浏览器中查看项目的样子)</li>
<li>q退出服务</li>
<li>退出项目目录</li>
<li>ionic start myApp “要安装的模板”</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/04/angular自定义指令/" itemprop="url">
                  前端必须要了解的面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="directive的参数及其使用办法"><a href="#directive的参数及其使用办法" class="headerlink" title="directive的参数及其使用办法"></a>directive的参数及其使用办法</h2><p><strong>具体代码</strong></p>
<pre><code>myModule.directive(&apos;directive&apos;, function () { 

     return { 

     　　priority: 0, 

     　　template: &apos;&lt;div&gt;&lt;/div&gt;&apos;, 

     　　templateUrl: &apos;directive.html&apos;, 

     　　replace: false, 

     　　transclude: false, 

     　　restrict: &apos;A&apos;, 

     　　scope: false, 

     　　compile: function compile(tElement, tAttrs, transclude) { 

     　　　　return { 

     　　　　　　pre: function preLink(scope, iElement, iAttrs, controller) { ... }, 

     　　　　　　post: function postLink(scope, iElement, iAttrs, controller) { ... } 

    　　　　} 

    　　}, 

     　　link: function postLink(scope, iElement, iAttrs) { ... }   
    }; 
}); 
</code></pre><p><strong>参数分析</strong></p>
<ul>
<li><p><strong>restrict</strong></p>
<p>  （字符串）可选参数，指明指令在DOM里面以什么形式被声明；取值有：E(元素),A(属性),C(类),M(注释)，其中默认值为A；当然也可以两个一起用，比如EA.表示即可以是元素也可以是属性。</p>
<pre><code>`[html] view plain copy `在CODE上查看代码片派生到我的代码片
 E(元素)：`&lt;directiveName&gt;&lt;/directiveName&gt;`  
 A(属性)：`&lt;div directiveName=&apos;expression&apos;&gt;&lt;/div&gt;`  
 C(类)： `&lt;div class=&apos;directiveName&apos;&gt;&lt;/div&gt;`  
 M(注释)：`&lt;--directive:directiveName expression--&gt;`  
 一般情况下E/A/C用得比较多。
</code></pre></li>
<li><p><strong>priority</strong>（不常用）</p>
<p> (数字)，可选参数，指明指令的优先级，若在单个DOM上有多个指令，则优先级高的先执行；</p>
</li>
<li><p><strong>terminal</strong>（不常用）</p>
<p>  （布尔型），可选参数，可以被设置为true或false，若设置为true，则优先级低于此指令的其他指令则无效，不会被调用(优先级相同的还是会执行)</p>
</li>
<li><p><strong>template</strong></p>
<p>  （字符串或者函数）可选参数，可以是：</p>
<p>  （1）一段HTML文本</p>
<p>  （2）一个函数，可接受两个参数<code>tElement</code>和<code>tAttrs</code><br>  其中tElement是指使用此指令的元素，而tAttrs则实例的属性，它是一个由元素上所有的属性组成的集合（对象）形如：<br>  <code>&lt;hello-world2 title = &#39;我是第二个directive&#39;&gt;&lt;/hello-world2&gt;</code><br>  其中title就是tattrs上的属性</p>
</li>
<li><p><strong>templateUrl</strong>（字符串或者函数），可选参数，可以是</p>
<p>  （1）一个代表HTML文件路径的字符串</p>
<p>  （2）一个函数，可接受两个参数<code>tElement</code>和<code>tAttrs</code>（大致同上）<br>  注意：在本地开发时候，需要运行一个服务器，不然使用templateUrl会报错 <code>Cross Origin Request Script（CORS）</code>错误。由于加载html模板是通过异步加载的，若加载大量的模板会拖慢网站的速度，这里有个技巧，就是先缓存模板</p>
</li>
<li><p><strong>replace</strong></p>
<p>  （布尔值），默认值为false，设置为true时候会去除自定义的标签，只显示标签里边的内容</p>
</li>
<li><p><strong>scope</strong></p>
<p>  （1）默认值false。表示继承父作用域;</p>
<p>  （2）true。表示继承父作用域，并创建自己的作用域（子作用域）;</p>
<p>  （3）{}。表示创建一个全新的隔离作用域；可以用“@”和“=”，“=”可以实现子元素和父元素的数据双向绑定，”@“是单向绑定，父级元素的属性修改子元素会修改，但是子元素修改父级元素不会修改</p>
</li>
<li><p><strong>controller</strong></p>
<p>  可以是一个字符串或者函数。<br>  若是为字符串，则将字符串当做是控制器的名字，来查找注册在应用中的控制器的构造函数</p>
</li>
<li><p><strong>controllerAs</strong></p>
<p>  这个选项的作用是可以设置你的控制器的别名</p>
</li>
<li><p><strong>compile</strong></p>
<p>  <code>compile</code>选项可以返回一个对象或者函数</p>
<p>  在这里我们可以在指令和实时数据被放到DOM中之前进行DOM操作，</p>
<p>  比如我们可以在这里进行添加或者删除节点的DOM的操作。</p>
<p>  所以编译函数是负责对模板的DOM进行转换，并且仅仅只会运行一次。</p>
<pre><code>//compile函数的语法
compile:function compile(tElement,tAttrs,transclude){
      return{
        pre:function preLink(scope,iElement,iAttrs,controller){},
        post:function postLink(scope,iElement,iAttrs,controller){}
      }
    }
</code></pre><p>  对于我们编写的大部分的指令来说，并不需要对模板进行转换，所以大部分情况只要编写<code>link</code>函数就可以了。</p>
<p>  <code>tips：preLink</code>函数会在编译阶段之后，指令链接到子元素之前执行</p>
<pre><code>类似的，`postLink`会在指令链接到子元素之后执行

这意味着，为了不破坏绑定过程，如果你需要修改DOM结构，你应该在`postLink`函数中来做这件事。
</code></pre><p>  13.2link链接函数选项</p>
<p>  链接函数负责将作用域和DOM进行链接。</p>
<p>  //link链接函数<br>  <code>link:function postLink(scope,iElement,iAttrs){}</code><br>  若指令中定义有require选项，则link函数会有第四个参数，代表控制器或者所依赖的指令的控制器（上面<code>require</code>选项例子已有例子）</p>
</li>
</ul>
<p>友情链接：<a href="https://my.oschina.net/u/1992917/blog/406421" title="雷锋叔叔的博客" target="_blank" rel="external">https://my.oschina.net/u/1992917/blog/406421</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="千禾页" />
          <p class="site-author-name" itemprop="name">千禾页</p>
          <p class="site-description motion-element" itemprop="description">To the world you may be one person,but to one person you may be the world.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ProgrammingAworld" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/03c7fc8d3c8b/latest_articles" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://tccpc.xyz" title="Tccpc博客" target="_blank">Tccpc博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">千禾页</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/libs/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/libs/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/libs/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/libs/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libs/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libs/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
