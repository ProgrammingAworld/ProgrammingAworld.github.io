<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/libs/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/libs/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="学习笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Gulp和Webpack功能实现对比简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。基本概念首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重">
<meta property="og:type" content="article">
<meta property="og:title" content="wekpack和gulp对比">
<meta property="og:url" content="http://yoursite.com/2016/11/04/webpack和gulp对比/index.html">
<meta property="og:site_name" content="最晚的开始">
<meta property="og:description" content="Gulp和Webpack功能实现对比简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。基本概念首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重">
<meta property="og:updated_time" content="2016-11-04T10:56:01.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wekpack和gulp对比">
<meta name="twitter:description" content="Gulp和Webpack功能实现对比简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。基本概念首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/11/04/webpack和gulp对比/"/>


  <title> wekpack和gulp对比 | 最晚的开始 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">最晚的开始</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">所有的为时已晚都是开始的最好时候</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                wekpack和gulp对比
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-04T08:32:47+08:00" content="2016-11-04">
              2016-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/webpack-gulp/" itemprop="url" rel="index">
                    <span itemprop="name">webpack gulp</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2>Gulp和Webpack功能实现对比</h2><br>简单介绍了一下Gulp和Webpack的概念性的问题和大环境，接下来进入本文的主题，对比一下Gulp和Webpack的优缺点。将从基本概念、启动本地Server、sass/less预编译、模块化开发、文件合并与压缩、mock数据、版本控制、组件控制八个方面对Gulp和Webpack进行对比。<br><br><h3>基本概念</h3><br><br>首先从概念上，我们可以清楚的看出，Gulp和Webpack的侧重点是不同的。<br><br>Gulp侧重于前端开发的整个过程的<strong>控制管理</strong>（像是流水线），我们可以通过给gulp配置不通的task（通过Gulp中的gulp.task()方法配置，比如启动server、sass/less预编译、文件的合并压缩等等）来让gulp实现不同的功能，从而构建整个前端开发流程。<br><br>Webpack有人也称之为<strong>模块打包机</strong>，由此也可以看出Webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块，最初Webpack本身就是为前端JS代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack是通过loader（加载器）和plugins（插件）对资源进行处理的。<br><br>另外我们知道Gulp是对整个过程进行控制，所以在其配置文件（gulpfile.js）中配置的每一个task对项目中该task配置路径下所有的资源都可以管理。<br>比如，对sass文件进行预编译的task可以对其配置路径下的所有sass文件进行预编译处理：<br><br>    gulp.task(‘sass’,function(){<br>        gulp.src(‘src/styles/<em>.scss’)<br>        .pipe(sass().on(‘error’,sass.logError))<br>        .pipe(gulp.dest(‘./build/prd/styles/‘));//编译后的输出路径<br>    });<br>上面这个task可以对’src/styles/</em>.scss’目录下的所有以.scss结尾的文件进行预处理。<br><br>Webpack则不是这样管理资源的，它是根据模块的<strong>依赖关</strong>系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><br>webpack通过依赖关系静态分析<br>通俗的说，Webpack就是需要通过其配置文件（webpack.config.js）中entry配置的一个入口文件（JS文件）,如下图<br><br>    entry: {<br>          app:<strong>dirname + “/src/scripts/app.js”,<br>    }<br>然后Webpack进入该app.js文件进行解析，app.js文件如下图：<br><br>    //引入scss文件<br>    import ‘../style/app.scss’;<br><br>    //引入依赖模块<br>    var greeter = require(‘./Greeter.js’);<br>    document.getElementById(‘root’).appendChild(greeter());<br><br>解析过程中，发现一个<code>app.scss</code>文件，然后根据<code>webpack.config.js</code>配置文件中的<code>module.loaders</code>属性去查找处理<code>.scss</code>文件的<code>loader</code>进行处理，处理<code>app.scss</code>文件过程中，如果发现该文件还有其他依赖文件，则继续处理<code>app.scss</code>文件的依赖文件，直至处理完成该“链路”上的依赖文件，然后又遇到一个<code>Greeter.js</code>模块，于是像之前一样继续去查找对应的loader去处理…<br>所以，Webpack中对资源文件的处理是通过入口文件产生的依赖形成的，不会像Gulp那样，配置好路径后，该路径下所有规定的文件都会受影响。<br><br><h3>模块化开发</h3><br><br>所谓的前端模块化开发，我的理解就是，在开发的时候，把不通的资源文件按照他的具体用途进行分类管理，在使用的时候利用CommonJS、AMD、CMD等规范将这些资源文件引入到当前文件中。然后在测试或者最后上线的时候，将这些资源文件按照一定的要求进行压缩合并再加上版本控制处理。<br>可能这样的理解或者说法值得商榷，但是个人还是觉得模块化就是对内容的管理，是为了解耦合。<br><br>首先从Gulp入手，看看在项目中，怎样利用模块化的思想进行开发。下面是一个gulp项目的目录结构：<br>gulp项目目录结构<br><br><br>Gulp<br><br> |——build:  项目输出路径<br> |    |——prd:  css、js文件输出路径<br> |        |——scripts: js文件的输出路径<br> |        |——styles: css文件的输出路径<br> |    |——ver: 版本号相关文件<br> |    |——index.html: 编译后的index.html<br> |——images: 图片文件夹<br> |——mock: mock数据文件夹<br> |——node_modules: npm包管理文件夹<br> |——src: 工作目录<br> |    |——scripts<br> |        |——libs: 第三方依赖库（jQuery等）<br> |        |——tpls: 模板文件<br> |        |——utils: 工具类文件夹<br> |        |——views: 页面自定义js文件<br> |        |——app.js: index.html文件的入口js<br> |    |——styles：文件和scripts文件夹下基本一致（本例中我引用了第三方框架，目录更深，不在展示）<br> |——gulpfile.js: gulp的配置文件<br> |——index.html: 主页html文件<br> |——package.json: npm包管理配置文件<br><br>在实际开发过程中，在src目录下工作，html、js和css等文件通过gulp的task配置，执行合并和压缩后输出到build目录下（下面会详细介绍合并压缩的实现）。在详细一点就是：<br><br>&gt;1. 创建主页html文件<br>&gt;2. 创建与之对应的app.js入口文件和app.scss入口文件。这两个文件只通过CommonJS规范引入各自views文件中自定义的js(或scss)文件，具体逻辑不写此文件中。<br>&gt;3. 在views目录下编写js（或css）文件的逻辑代码，其中如果多个文件需要公共逻辑或者工具方法，就可以抽离出来在util文件夹下创建对应的公共方法，然后在views中需要的js（或css）文件中通过CommonJS规范引入使用。libs目录下的第三方库或框架也是这个思想去引用。<br>&gt;4.scripts目录下的tpls文件是用来放置html模板的，引用方式和引用libs相同。<br>大体介绍了一下我理解的模块化的思想，但是需要指出的是Gulp对js文件的模块化工作是通过Webpack实现的，具体来说是通过安装gulp-webpack模块和相关的loader模块进行js模块化管理的。具体步骤如下：<br><br>1.在项目中通过npm安装一个gulp-webpack、vinyl-named、imports-loader和string-loader模块(压缩合并模块后面再介绍)<br><br>    $ npm install gulp-webpack vinyl-named -D<br>2.然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webpack 模块，并进行简单配置<br><br>       //1.引入 gulp-webpack和vinyl-named模块<br>      var webpack= require(‘gulp-webpack’);<br>      var webpack= require(‘vinyl-named’);<br>       //2.js 模块化配置<br>      var jsFiles = [<br>        ‘./src/scripts/*.js’,<br>      ];<br>      gulp.task(‘packjs’,function(){<br>    gulp.src(jsFiles)<br>    .pipe(uglify().on(‘error’,function(err){<br>       console.log(‘\x07’,err.lineNumber,err.message);<br>       return this.end();<br>     }))<br><br>    //Webpack 对js模块化部分 start<br>    .pipe(webpack({<br>        output:{<br>          filename:’[name].js’<br>        },<br>        module:{<br>            loaders:[{<br>              test: /.js$/,<br>              loader:’imports?define=&gt;false’<br>            },<br>            {<br>              test:/.string$/,<br>              loader:’string’<br>            }<br>          ]<br>        }<br>      }));<br>      //Webpack 对js模块化部分 end<br>    .pipe(concat(‘all.js’))<br>    .pipe(gulp.dest(‘./build/prd/scripts/‘));<br>});<br>对css文件我们也采用同js文件一样的模块化思想，利用sass进行模块化开发，至于对scss文件的合并压缩配置，下面还会详细介绍。<br><br>接下来应该介绍一下Webpack的模块化实现了，其实也就没什么可以说的了，文件目录和Gulp的基本相同，只不过实现过程中使用到的插件或者说模块不同，配置不同而已。另外需要注意的是，Webpack对于资源文件的模块化打包处理都是按js文件的处理方式处理的，例如还是上一小节中，你可能发现了，我在<code>app.js</code>入口文件中有这样一行代码<br><br>    import ‘../style/app.scss’;<br>你当时可能产生疑问，为什么在js文件中引入scss文件呢？<br>这是因为Webpack是通过依赖关系进行文件管理的，所以，想要对样式文件进行模块化管理则必须与<code>app.js</code>入口文件建立依赖关系，因此我们将样式文件的入口<code>app.scss</code>文件引入到了<code>app.j</code>s中（其他资源想要被管理，也需要这样与<code>app.js</code>入口文件建立依赖关系）。<br>但是这样做很明显的就是样式文件通过<code>app.js</code>入口文件全部都合并压缩到js文件中了，这很显然不是我们想要的结果，所以我们需要将样式文件从js文件中剥离出来。<br><br>  在项目中通过npm安装一个extract-text-webpack-plugin的模块<br><br>    $ npm install  extract-text-webpack-plugin -D<br>然后在Webpack的配置文件webpack.config.js中进行简单配置<br><br>     //1.引入extract-text-webpack-plugin模块<br>     var Et = require(‘extract-text-webpack-plugin’);<br>     module.exports = {<br>       //source-map调试<br>       devtool: ‘eval-source-map’,<br>       //webpack入口文件配置<br>       entry: {<br>       app:</strong>dirname + “/src/scripts/app.js”,<br>       },<br>       //webpack出口文件配置<br>       output: {<br>           path: <strong>dirname + “/prd/scripts/“,//输出文件路径配置<br>           filename: “bundle.js”//输出文件名配置<br>       },<br>       module:{<br>           loaders:[<br>             {<br>                 test: /.scss$/,<br>                 loader: Et.extract(‘style’,’css!sass’)//从js中抽离scss文件<br>             }<br>           ]<br>        },<br>       plugins: [<br>           new Et(‘./styles/bundle.css’),//从js中抽离scss文件输出目录设置<br>       ],<br>       //本地server配置<br>       devServer: {<br>         contentBase:  </strong>dirname + ‘/prd/‘,//本地服务器所加载的页面所在的目录<br>         port:8089,//本地服务端口配置<br>         colors: true,//终端中输出结果为彩色<br>         historyApiFallback: true,//不跳转<br>         inline: true//实时刷新<br>       }<br>    }<br>上面有些配置信息并不完全，下面的小节中会逐渐介绍到。这样我们就实现了将css文件从js文件中剥离出来的目的。Webpack不但可以对css文件可以进行模块化管理，还可以对图片进行模块管理，有兴趣的可以自己去尝试一下。<br><br><h2>文件合并与压缩</h2>

<p>上面的模块化中，我们提到了模块化其实很大一部分是在做文件的合并与压缩操作，所以我们马上来看看Gulp和Webpack是怎样是想文件的合并和压缩的。</p>
<p>先来看看大背景，由于现在前端越来越庞大，页面文件依赖也越来越多，所以对这些文件进行合理的合并和压缩就志在必得。根据前面的了解，Webpack应该比Gulp更擅长文件合并和压缩，毕竟人家被称为模块打包机吗。<br>结论是正确的，Gulp可以对css文件以及js文件进行合并压缩处理，而Webpack可以实现对css文件，js文件，html文件等进行合并压缩和图片的压缩，还可以对js文件进行编译（如es6–&gt;es5，react jsx）等等，这些都是通过Webpack的loader实现的，当然这些也可以加入到Gulp中，毕竟Gulp把Webpack当做一个模块，通过gulp-webpack都引入了。</p>
<h3>Gulp合并压缩文件</h3>

<p><strong>css的压缩</strong> </p>
<p>要想实现Gulp对css文件的压缩只需要安装一个gulp-minify-css模块即可。</p>
<p>  在项目中通过npm安装一个gulp-minify-css的模块</p>
<pre><code>$ npm install gulp-minify-css -D
</code></pre><p>  然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-minify-css模块，并进行简单配置</p>
<pre><code> //1.引入 gulp-minify-css模块
var minifyCSS = require(&apos;gulp-minify-css&apos;);
//2.css 预处理
var cssFiles = [
  &apos;./src/styles/usage/page/index.scss&apos;
]
gulp.task(&apos;sass&apos;,function(){
    gulp.src(cssFiles)
    .pipe(sass().on(&apos;error&apos;,sass.logError))
    .pipe(minifyCSS())//执行压缩处理在一行
    .pipe(gulp.dest(&apos;./build/prd/styles/&apos;));
});
</code></pre><p>这样一个简单的css压缩就实现了。</p>
<p><strong>js合并压缩</strong></p>
<p>要想实现Gulp对js文件的合并压缩需要安装一个gulp-uglify和gulp-concat两个模块，前者是用于压缩的模块，后者是一个合并的模块。</p>
<p>  在项目中通过npm安装gulp-uglify和gulp-concat模块</p>
<pre><code>$ npm install gulp-uglify gulp-concat -D
</code></pre><p>  然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-uglify和gulp-concat模块，并进行简单配置</p>
<pre><code> //1.引入**gulp-uglify**和**gulp-concat**模块
 var uglify = require(&apos;gulp-uglify&apos;);
 var concat = require(&apos;gulp-concat&apos;);
//js 合并压缩
 var jsFiles = [
    &apos;./src/scripts/*.js&apos;,
  ];
  gulp.task(&apos;packjs&apos;,function(){
    gulp.src(jsFiles)
    //js文件的压缩
    .pipe(uglify().on(&apos;error&apos;,function(err){
       console.log(&apos;\x07&apos;,err.lineNumber,err.message);
       return this.end();
     }))
    .pipe(webpack({
        output:{
          filename:&apos;[name].js&apos;
        },
        module:{
            loaders:[{
              test: /\.js$/,
              loader:&apos;imports?define=&gt;false&apos;
            },
            {
              test:/\.string$/,
              loader:&apos;string&apos;
            }
          ]
        }
      }));
    //js文件的合并
    .pipe(concat(&apos;all.js&apos;))
    .pipe(gulp.dest(&apos;./build/prd/scripts/&apos;));
});
</code></pre><p>js的文件合并压缩也完成了。我们再来看一下Webpack的合并压缩。</p>
<h3>Webpack的合并压缩</h3>

<p><strong>压缩js和css</strong></p>
<p>针对js和css文件的压缩，Webpack已经内嵌了uglifyJS来完成对js与css的压缩混淆，无需引用额外的插件。我们只需要在Webpack配置文件中的plugins属性中做如下配置：</p>
<pre><code>  plugins: [
    new webpack.optimize.UglifyJsPlugin({ //压缩代码
      compress: {
        warnings: false
      },
      except: [&apos;$super&apos;, &apos;$&apos;, &apos;exports&apos;, &apos;require&apos;] //排除关键字
  })
]
</code></pre><p>需要注意的是：压缩的时候需要排除一些关键字，不能混淆，比如$或者require，如果混淆的话就会影响到代码的正常运行。</p>
<h3>html的压缩</h3>

<p>想要对html进行压缩，同样也是需要配置Webpack的配置文件，并且需要下载两个插件HtmlWebpackPlugin和html-minifier插件：<br>1.在项目中通过npm安装HtmlWebpackPlugin和html-minifier模块</p>
<pre><code>$ npm install HtmlWebpackPlugin -D
$ npm install html-minifier -D
</code></pre><p>2.然后在Webpack的配置文件webpack.config.js进行如下配置：</p>
<pre><code>plugins: [
   new HtmlWebpackPlugin({ //根据模板插入css/js等生成最终HTML
       favicon:&apos;./src/img/favicon.ico&apos;, //favicon路径
       filename:&apos;/view/index.html&apos;, //生成的html存放路径
       template:&apos;./src/view/index.html&apos;, //html模板路径
       inject:true, //允许插件修改哪些内容，包括head与body
      hash:true, //为静态资源生成hash值
      minify:{ //压缩HTML文件
          removeComments:true, //移除HTML中的注释
           collapseWhitespace:true //删除空白符与换行符
       }
  })
 ]
</code></pre><p>HtmlWebpackPlugin插件在生成HTML时调用了 html-minifier 插件来完成对HTML的压缩，这里我们使用两个配置完成来移除HTML中的注释以及空白符达到压缩的效果。</p>
<h3>sass/less预编译</h3>

<p>我们再来看看<code>sass/less</code>预编译，其实就<code>sass/less</code>的预编译来说，两者区别不是很大。Gulp是通过g<code>ulp-sass、gulp-less</code>模块进行预处理；而Webpack是通过<code>scss-loader、less-loader</code>加载器（loader）进行预处理。我们还是分别来看一下两者对此的实现。</p>
<h3>Gulp预编译sass/less</h3>

<p>以sass为例子：</p>
<p>在项目中通过npm安装一个gulp-sass的模块</p>
<pre><code>$ npm install gulp-sass -D
</code></pre><p>然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-sass模块，并进行简单配置</p>
<pre><code> //1.引入 gulp-sass模块
var sass= require(&apos;gulp-sass&apos;);
//2.css 预处理
var cssFiles = [
  &apos;./src/styles/usage/page/**/*&apos;
  //./src/styles/usage/page目录下的所有文件
];
gulp.task(&apos;sass&apos;,function(){
    gulp.src(cssFiles)
    .pipe(sass().on(&apos;error&apos;,sass.logError))
    .pipe(minifyCSS())
    .pipe(gulp.dest(&apos;./build/prd/styles/&apos;));//编译后的输出路径
});

//3.对sass文件的修改添加监听事件
gulp.task(&apos;watch&apos;,function(){
   gulp.watch(&apos;./src/styles/**/*&apos;,[&apos;sass&apos;]);
});
gulp.task(&apos;default&apos;,[&apos;watch&apos;,&apos;webserver&apos;],function(){
    console.log(&apos;所有任务队列执行完毕&apos;);
});
</code></pre><p>这样，一个简单的sass预处理的task就配置完成了，然后我们还将该task加到gulp.watch()上实现了自动编译（即修改sass文件后保存，则立即执行sass预处理），配合Gulp启动的server则可以实现sass文件修改保存即可在浏览器中查看效果的目的，下一小节会介绍启动本地server。</p>
<h3>Webpack预编译sass/less</h3>

<p>同样以sass为例子：</p>
<p>在项目中通过npm安装一个sass-loader和node-sass模块，前者是用来加载sass相关文件的，后者是用来编译sass文件的。另外还需要安装另外两个模块css-loader和style-loader，前者是用来加载css相关文件的，后者是用来将css样式装填到html中的内联样式。</p>
<pre><code>$ npm install sass-loader node-sass css-loader style-sass -D
</code></pre><p>然后在Webpack的配置文件webpack.config.js中进行简单配置</p>
<pre><code> module:{
      loaders:[
      {
          test: /\.css$/,//匹配以.css结尾的文件，如果你项目不需要刻意不配置
          loader: &apos;style!css&apos;//这里顺序必须这样  
      },
      {
          test: /\.scss$/,//匹配以.scss结尾的文件
          loader: &apos;style!css!sass&apos;
      }
    ]
}
</code></pre><p>前面提到过，Webpack是通过文件的依赖关系进行加载分析的，所以当程序从主入口（js文件）进入后，在依赖的资源文件中发现有sass文件后，就会利用我们配置的sass-loader去加载，然后用node-sass去解析编译成普通的css语法的样式文件，在然后就是利用style-loader将样式以内联样式的形式配置到html中（这里有一个问题，就是css-loader有什么用?我也没搞明白，但是不添加会报错，有知道的可以留言交流一下）。这样Webpack就完成了sass的预处理。</p>
<h3>启动server</h3>

<p>我们都知道在前端开发中，ajax请求是需要启动一个server的。特别是在前后端分离思想中，前端开发不再像以前一样过分依赖于后端开发，以前的那种前端测试ajax请求需要装个tomcat或者其它服务器来启动server的现象已经成为过去式，现在我们可以使用像Gulp这类前端自动构建工具启动一个本地server进行测试，再也不收后端程序员钳制了（开个玩笑，和后端好好沟通才能让前端开发更方便）。那么，我们来分别看一下Gulp和Webpack是怎样实现这个功能的。</p>
<h3>Gulp启动server</h3>

<p>在Gulp中想要启动一个本地serve，只需要以下几步：</p>
<p>在项目中通过npm安装一个gulp-webserver的模块</p>
<pre><code>$ npm install gulp-webserver -D
</code></pre><p>然后在Gulp的配置文件gulpfile.js中通过CommonJs规范引入gulp-webserver模块，并进行简单配置</p>
<pre><code> //1.引入 gulp-webserver 模块
var webserver = require(&apos;gulp-webserver&apos;);
//2.配置server task
gulp.task(&apos;webserver&apos;,function(){
  gulp.src(&apos;./&apos;)
  .pipe(webserver({
      host:&apos;localhost&apos;,
      port:80,
      //浏览器自动刷新
      livereload:true,
      //显示文件目录
      directoryListing:{
        enable: true,
        path:&apos;./&apos;
      },
    }));
});
//3.配置默认task
gulp.task(&apos;default&apos;,[&apos;webserver&apos;],function(){
    console.log(&apos;启动任务队列执行完毕&apos;);
})
</code></pre><p>在命令行中启动server</p>
<pre><code>$ gulp
</code></pre><p>启动成功：</p>
<pre><code>gulp cli 启动成功
</code></pre><p>在浏览器地址栏中输入localhost打开页面验证。<br>经过以上这三步，我们就在Gulp中启动了一个server了。在Gulp中启动本地服务有一个很方便的配置，就是<code>livereload:true</code>属性的设置，设置后浏览器会根据你项目中资源的变化自动刷新浏览器（如果你的chrome浏览器设置该属性后在你修改文件并保存时仍没有自动刷新，可能是你的chrome浏览器不支持，可以chrome扩展程序中搜索并安装LiveReload插件），比如：<br>我的gulp测试目录结构：<br>gulp测试目录结构</p>
<p>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;Document&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;script src=&quot;/src/scripts/app.js&quot;&gt;&lt;/script&gt;
 &lt;/body&gt;
</code></pre><p><br>我在app.js文件中输入以下内容，然后保存。</p>
<pre><code>console.log(&apos;gulp-webserver livereload&apos;);
</code></pre><p>浏览器中控制台上会立刻打印出一下信息：<br>gulp测试目录结构<br>说明浏览器自动刷新工程，这个小功能在我们开发中屡试不爽。但是，这个功能是需要结合上一小节中的<code>gulp.watch()</code>实时监控文件变化，然后执行合并压缩和<code>sass/less</code>编译等操作后，浏览器再刷新时才能保证是我们修改后的内容。所以，<code>livereload:tru</code>e属性只是监控到我们修改文件后刷新浏览器重新请求文件，如果我们不重新编译修改后的文件，浏览器获取到的还是原文件，并不会展示变化。</p>
<h3>Webpack启动server</h3>

<p>在Webpack中也可以通过插件的形式安装一个webpack-dev-server来实现达到启动本地server的目的，具体步骤如下：</p>
<p>在项目中通过npm安装一个webpack-dev-server的模块</p>
<pre><code>$ npm install  -g webpack-dev-server -D
</code></pre><p>然后在Webpack的配置文件webpack.config.js中进行简单配置</p>
<pre><code> module.exports = {
   devtool: &apos;eval-source-map&apos;,
   //webpack入口文件配置
   entry: {
   app:__dirname + &quot;/src/scripts/app.js&quot;,
   },
   //webpack出口文件配置
   output: {
       path: __dirname + &quot;/prd/scripts/&quot;,//输出文件路径配置
       filename: &quot;bundle.js&quot;//输出文件名配置
   },
   //本地server配置
   devServer: {
     contentBase:  __dirname,//本地服务器所加载的页面所在的目录
     port:8089,//本地服务端口配置
     colors: true,//终端中输出结果为彩色
     historyApiFallback: true,//不跳转
     inline: true//实时刷新
   }
}
</code></pre><p>在命令行中启动server</p>
<pre><code>$ webpack-dev-server
</code></pre><p>然后你就会看见命令行输出内容很多，只要看看保证没有Error就说明成功了。</p>
<p> 在浏览器地址栏中输入localhost：8089测试一下。<br>Webpack的启动本地服务也顺利实现了，是不是也想实现像Gulp一样浏览器自动刷新呀？那Webpack能不能实现呢？答案是肯定的，Webpack官方提供了一个辅助开发工具，它可以自动监控项目下的文件，一旦有修改保存操作，开发服务器就会自动运行Webpack 打包命令，帮我们自动将开发的代码重新打包。而且，如果需要的话，还能自动刷新浏览器，重新加载资源。理论上好像是这样，但是实现好像有不少限制，比如，HTML文件的自动刷新问题（html-webpack-plugin插件使用老是报错），当本地server启动在非output.path路径之外时则不能自动刷新等问题。</p>
<p>而这个辅助工具就是<code>webpack-dev-server</code>，它主要提供两个功能：一是为静态文件提供server服务，二是自动刷新和热替换(HMR)。所以想实现如Gulp一样的功能也是可以的，只需要在<code>$ webpack-dev-server</code>后面添加<code>--inline --hot</code>即可。需要注意的是–inline是自动刷新，同时在第二部中的devServer属性中有一个inline:true需要配置；而–hot是热替换（详细了解热替换、了解<code>webpack-dev-server、webpack-dev-server）</code>。</p>
<p>通过对比来看，好像Webpack的<code>webpack-dev-server</code>比Gulp的<code>gulp-server</code>功能要强一些。因为通过上面可以看出webpack-dev-server有两个大功能：一是为静态文件提供server服务，二是自动刷新（自动刷新其实需要两步：1.修改文件后，文件自动编译{包括合并压缩或者语法编译等}，2.刷新浏览器请求最新编译后的文件）和热替换(HMR)；而gulp-server虽然提供了启动本地server的能力和仅自动刷新浏览器的能力，缺少一个文件自动编译的能力，这需要借助其他模块实现（上一小节已介绍，结合gulp.watch()实时监控文件变化，并编译）。</p>
<p>另外需要注意的是，实际开发中发现<code>webpack-dev-server</code>实现自动刷新的时候，并没有执行自动编译，只是将修改的内容合并压缩等处理后发送给了浏览器，并造成了已经编译的现象，但是通过<code>build/prd/scripts</code>目录下的<code>bundle.js</code>(合并压缩后的输出文件)文件，可以发现内容并没有编译（对于Webpack还是不熟悉，好多问题等待解决）。</p>
<h3>mock数据</h3>

<p>在现在前后端分离的思想中，前端和后端耦合度越来越小，现在唯一需要前后端密切联系的就是借口的定义和数据格式的确定。一般在项目开始前，前端和后端将项目中的接口和数据格式全部确定下来（当然项目需求变更就需要临时确立这些共识了），然后前端就可以自己mock数据了。</p>
<h3>Gulp实现mock数据</h3>

<p>Gulp中对mock数据的实现使通过NodeJS内置的fs模块和url模块实现的，因为Gulp本身就是基于NodeJS的。还记得第一小节“模块化开发”中目录结构中的那个mock目录吗？那就是用来储存.json文件的mock数据目录。</p>
<blockquote>
<p>配置Gulp的gulpfile.js文件</p>
</blockquote>
<pre><code>//1.引入 fs 和 url 模块
var fs = require(&apos;fs&apos;);
var url = require(&apos;url&apos;);
//2.重新配置一下上一小节的server
gulp.task(&apos;webserver&apos;,function(){
   gulp.src(&apos;./&apos;)
   .pipe(webserver({
      host:&apos;localhost&apos;,
      port:80,
      livereload:true,
      directoryListing:{
        enable: true,
        path:&apos;./&apos;
    },
    //mock数据配置
    middleware:function(req,res,next){
      var urlObj = url.parse(req.url,true);
      switch (urlObj.pathname) {
          case &apos;/pro/getPro&apos;:
            res.setHeader(&apos;Content-Type&apos;,&apos;application/json;charaset=utf-8&apos;);
            fs.readFile(&apos;./mock/list.json&apos;,function(err,data){
              //上面list.json路径使用相对路径，绝对路径前台无法获取数据
              res.end(data);
            });
            return;
          case &apos;/web/getUser&apos;:
              //....
            return;
        }
        next();
      }
    }));
});
</code></pre><p>具体来说，就是通过NodeJS拦截http请求，根据请求URL来模拟后端做出处理后返回不同的数据。</p>
<h3>版本控制</h3>

<p>对于版本控制，我们在开发过程中，也是一个使用比较频繁的功能，特别是开发团队比较大的时候，这个功能就显得更加重要了。那么Gulp和Webpack是具体怎样实现的呢？</p>
<h3>Gulp实现版本控制</h3>

<p>在项目中通过npm安装gulp-rev和gulp-rev-collector模块，前者用于生成文件的MD5码文件和按MD5码命名的资源文件，后者是利用MD5码，对文件名进行替换。</p>
<pre><code>$ npm install  gulp-rev gulp-rev-collector -D
</code></pre><p>然后在Gulp的配置文件gulpfile.js中进行简单配置</p>
<pre><code>  //1.引入连个模块
  var rev = require(&apos;gulp-rev&apos;);
  var revCollector = require(&apos;gulp-rev-collector&apos;);
  // 2.版本号控制
  gulp.task(&apos;ver&apos;,function(){
    gulp.src(cssFiles)
    .pipe(rev())//产生MD5码
    .pipe(gulp.dest(&apos;./build/prd/styles/&apos;))//重命名文件
    .pipe(rev.manifest())//产生版本信息的json文件
    .pipe(gulp.dest(&apos;./build/ver/styles/&apos;));
  gulp.src(jsFiles)
  .pipe(rev())
  .pipe(gulp.dest(&apos;./build/prd/scripts/&apos;))
  .pipe(rev.manifest())
  .pipe(gulp.dest(&apos;./build/ver/scripts/&apos;));
 })
 //动态修改html中对css和js文件的修改
 gulp.task(&apos;html&apos;,function(){
  gulp.src([&apos;./build/ver/**/*&apos;,&apos;./build/*.html&apos;])
  .pipe(revCollector())
  .pipe(gulp.dest(&apos;./build/&apos;));
})
</code></pre><p>Gulp实现版本控制很方便，将这两个task加入<code>gulp.watch()</code>中，即可实现修改保存文件实时自动修改版本的功能。</p>
<p>Webpack实现版本控制</p>
<p>Webpack中需要版本控制的有<code>css、js</code>文件，不过Webpack的版本控制只实现了将<code>css、js</code>文件添加hash值方式命名的文件方式，修改引用路径中的文件名需手动实现。<br>不过实现确实很简单，只需要将<code>webpack.config.js</code>配置文件中的<code>output.filename</code>和<code>plugins</code>中的输出文件名称修改一下即可。</p>
<pre><code>module.exports = {
    devtool: &apos;eval-source-map&apos;,
    entry: {
    app:__dirname + &quot;/src/scripts/app.js&quot;,
    },
    output: {
        path: __dirname + &quot;/prd/scripts/&quot;,
        filename: &quot;[name]-[hash].js&quot;//修改输出文件名
    },
    plugins: [
        new Et(&apos;./styles/[name]-[hash].css&apos;),//修改输出文件名
    ]
 }
</code></pre>
      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg" alt="千禾页 wechat" style="width: 200px; max-width: 100%;"/>
    <div>ex. subscribe to my blog by scanning my public wechat account</div>
</div>


      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/images/wechat-reward-image.png" alt="千禾页 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/uploads/images/alipay-reward-image.png" alt="千禾页 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/学习笔记/" rel="tag">#学习笔记</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/04/vue--webpack/" rel="next" title="vue+webpack环境的搭建">
                <i class="fa fa-chevron-left"></i> vue+webpack环境的搭建
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/04/前端开发面试题/" rel="prev" title="前端面试题">
                前端面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="千禾页" />
          <p class="site-author-name" itemprop="name">千禾页</p>
          <p class="site-description motion-element" itemprop="description">My goal is not write code.if we could ship products and make all this money without writing any code,we could.Your job is ship products EXACTLY on time.It doesn’t matter whether you are a developer,tester,program manager,product manager whatever.Everybody’s job is the same.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ProgrammingAworld" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/03c7fc8d3c8b/latest_articles" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://tccpc.xyz" title="Tccpc博客" target="_blank">Tccpc博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">Gulp和Webpack功能实现对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.2.</span> <span class="nav-text">模块化开发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">文件合并与压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.1.</span> <span class="nav-text">Gulp合并压缩文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.</span> <span class="nav-text">Webpack的合并压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.3.</span> <span class="nav-text">html的压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.</span> <span class="nav-text">sass/less预编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.</span> <span class="nav-text">Gulp预编译sass/less</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.</span> <span class="nav-text">Webpack预编译sass/less</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.7.</span> <span class="nav-text">启动server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.8.</span> <span class="nav-text">Gulp启动server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.9.</span> <span class="nav-text">Webpack启动server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.10.</span> <span class="nav-text">mock数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.11.</span> <span class="nav-text">Gulp实现mock数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.12.</span> <span class="nav-text">版本控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.13.</span> <span class="nav-text">Gulp实现版本控制</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">千禾页</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/libs/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/libs/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/libs/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/libs/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libs/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libs/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
